// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: moskit.proto
#define PROTOBUF_INLINE_NOT_IN_HEADERS 0
#ifndef PROTOBUF_moskit_2eproto__INCLUDED
#define PROTOBUF_moskit_2eproto__INCLUDED


#ifdef _MSC_VER
#include "AllowWindowsPlatformTypes.h" // Added for UE4 in 2018-04-23 01:01:12.293075(UTC)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

#ifdef _MSC_VER
#include "HideWindowsPlatformTypes.h" // Added for UE4 in 2018-04-23 01:01:12.293075(UTC)
#endif

#include "Vector.h"
#include "Rotator.h"

namespace MSAnalyzer {
	namespace MOSKIT_UNITY_LIB {

		// Internal implementation detail -- do not call these.
		void protobuf_AddDesc_moskit_2eproto();
		void protobuf_InitDefaults_moskit_2eproto();
		void protobuf_AssignDesc_moskit_2eproto();
		void protobuf_ShutdownFile_moskit_2eproto();

		class AnalysisBuffer;
		class ArrayScene;
		class Component;
		class Controller;
		class GameObject;
		class MainCamera;
		class Scene;
		class Time;
		class Transform;
		class Vector3;

		// ===================================================================

		class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3) */ {
		public:
			Vector3();
			Vector3(const FVector& value)
			{
				set_x(value.X);
				set_y(value.Y);
				set_z(value.Z);
			};
			Vector3(const FRotator& value)
			{
				set_x(value.Roll);
				set_y(value.Pitch);
				set_z(value.Yaw);

			};
			Vector3(float x, float y, float z)
			{
				set_x(x);
				set_y(y);
				set_z(z);
			};
			virtual ~Vector3();

			Vector3(const Vector3& from);

			inline Vector3& operator=(const Vector3& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const Vector3& default_instance();

			static const Vector3* internal_default_instance();

			void Swap(Vector3* other);

			// implements Message ----------------------------------------------

			inline Vector3* New() const { return New(NULL); }

			Vector3* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const Vector3& from);
			void MergeFrom(const Vector3& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(Vector3* other);
			void UnsafeMergeFrom(const Vector3& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// optional float x = 1;
			bool has_x() const;
			void clear_x();
			static const int kXFieldNumber = 1;
			float x() const;
			void set_x(float value);

			// optional float y = 2;
			bool has_y() const;
			void clear_y();
			static const int kYFieldNumber = 2;
			float y() const;
			void set_y(float value);

			// optional float z = 3;
			bool has_z() const;
			void clear_z();
			static const int kZFieldNumber = 3;
			float z() const;
			void set_z(float value);

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3)
		private:
			inline void set_has_x();
			inline void clear_has_x();
			inline void set_has_y();
			inline void clear_has_y();
			inline void set_has_z();
			inline void clear_has_z();

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			float x_;
			float y_;
			float z_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<Vector3> Vector3_default_instance_;

		// -------------------------------------------------------------------

		class Transform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Transform) */ {
		public:
			Transform();
			virtual ~Transform();

			Transform(const Transform& from);

			inline Transform& operator=(const Transform& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const Transform& default_instance();

			static const Transform* internal_default_instance();

			void Swap(Transform* other);

			// implements Message ----------------------------------------------

			inline Transform* New() const { return New(NULL); }

			Transform* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const Transform& from);
			void MergeFrom(const Transform& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(Transform* other);
			void UnsafeMergeFrom(const Transform& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 eulerAngles = 1;
			bool has_eulerangles() const;
			void clear_eulerangles();
			static const int kEulerAnglesFieldNumber = 1;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& eulerangles() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_eulerangles();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_eulerangles();
			void set_allocated_eulerangles(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* eulerangles);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 position = 2;
			bool has_position() const;
			void clear_position();
			static const int kPositionFieldNumber = 2;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& position() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_position();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_position();
			void set_allocated_position(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* position);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 angularVelocity = 3;
			bool has_angularvelocity() const;
			void clear_angularvelocity();
			static const int kAngularVelocityFieldNumber = 3;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& angularvelocity() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_angularvelocity();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_angularvelocity();
			void set_allocated_angularvelocity(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* angularvelocity);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 scale = 4;
			bool has_scale() const;
			void clear_scale();
			static const int kScaleFieldNumber = 4;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& scale() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_scale();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_scale();
			void set_allocated_scale(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* scale);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 forward = 5;
			bool has_forward() const;
			void clear_forward();
			static const int kForwardFieldNumber = 5;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& forward() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_forward();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_forward();
			void set_allocated_forward(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* forward);

			// optional int32 parent = 6;
			bool has_parent() const;
			void clear_parent();
			static const int kParentFieldNumber = 6;
			::google::protobuf::int32 parent() const;
			void set_parent(::google::protobuf::int32 value);

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Transform)
		private:
			inline void set_has_eulerangles();
			inline void clear_has_eulerangles();
			inline void set_has_position();
			inline void clear_has_position();
			inline void set_has_angularvelocity();
			inline void clear_has_angularvelocity();
			inline void set_has_scale();
			inline void clear_has_scale();
			inline void set_has_forward();
			inline void clear_has_forward();
			inline void set_has_parent();
			inline void clear_has_parent();

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* eulerangles_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* position_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* angularvelocity_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* scale_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* forward_;
			::google::protobuf::int32 parent_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<Transform> Transform_default_instance_;

		// -------------------------------------------------------------------

		class MainCamera : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera) */ {
		public:
			MainCamera();
			virtual ~MainCamera();

			MainCamera(const MainCamera& from);

			inline MainCamera& operator=(const MainCamera& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const MainCamera& default_instance();

			static const MainCamera* internal_default_instance();

			void Swap(MainCamera* other);

			// implements Message ----------------------------------------------

			inline MainCamera* New() const { return New(NULL); }

			MainCamera* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const MainCamera& from);
			void MergeFrom(const MainCamera& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(MainCamera* other);
			void UnsafeMergeFrom(const MainCamera& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// optional string name = 1;
			bool has_name() const;
			void clear_name();
			static const int kNameFieldNumber = 1;
			const ::std::string& name() const;
			void set_name(const ::std::string& value);
			void set_name(const char* value);
			void set_name(const char* value, size_t size);
			::std::string* mutable_name();
			::std::string* release_name();
			void set_allocated_name(::std::string* name);

			// optional bool active = 2;
			bool has_active() const;
			void clear_active();
			static const int kActiveFieldNumber = 2;
			bool active() const;
			void set_active(bool value);

			// optional int32 layer = 3;
			bool has_layer() const;
			void clear_layer();
			static const int kLayerFieldNumber = 3;
			::google::protobuf::int32 layer() const;
			void set_layer(::google::protobuf::int32 value);

			// optional int32 instanceID = 4;
			bool has_instanceid() const;
			void clear_instanceid();
			static const int kInstanceIDFieldNumber = 4;
			::google::protobuf::int32 instanceid() const;
			void set_instanceid(::google::protobuf::int32 value);

			// optional string tag = 5;
			bool has_tag() const;
			void clear_tag();
			static const int kTagFieldNumber = 5;
			const ::std::string& tag() const;
			void set_tag(const ::std::string& value);
			void set_tag(const char* value);
			void set_tag(const char* value, size_t size);
			::std::string* mutable_tag();
			::std::string* release_tag();
			void set_allocated_tag(::std::string* tag);

			// optional float FieldOfView = 6;
			bool has_fieldofview() const;
			void clear_fieldofview();
			static const int kFieldOfViewFieldNumber = 6;
			float fieldofview() const;
			void set_fieldofview(float value);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 7;
			bool has_transform() const;
			void clear_transform();
			static const int kTransformFieldNumber = 7;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& transform() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* mutable_transform();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* release_transform();
			void set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 hitpoint = 8;
			bool has_hitpoint() const;
			void clear_hitpoint();
			static const int kHitpointFieldNumber = 8;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& hitpoint() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_hitpoint();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_hitpoint();
			void set_allocated_hitpoint(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* hitpoint);

			// optional float fIPD = 9;
			bool has_fipd() const;
			void clear_fipd();
			static const int kFIPDFieldNumber = 9;
			float fipd() const;
			void set_fipd(float value);

			// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Component list_Component = 10;
			int list_component_size() const;
			void clear_list_component();
			static const int kListComponentFieldNumber = 10;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Component& list_component(int index) const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Component* mutable_list_component(int index);
			::MSAnalyzer::MOSKIT_UNITY_LIB::Component* add_list_component();
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >*
				mutable_list_component();
			const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >&
				list_component() const;

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera)
		private:
			inline void set_has_name();
			inline void clear_has_name();
			inline void set_has_active();
			inline void clear_has_active();
			inline void set_has_layer();
			inline void clear_has_layer();
			inline void set_has_instanceid();
			inline void clear_has_instanceid();
			inline void set_has_tag();
			inline void clear_has_tag();
			inline void set_has_fieldofview();
			inline void clear_has_fieldofview();
			inline void set_has_transform();
			inline void clear_has_transform();
			inline void set_has_hitpoint();
			inline void clear_has_hitpoint();
			inline void set_has_fipd();
			inline void clear_has_fipd();

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component > list_component_;
			::google::protobuf::internal::ArenaStringPtr name_;
			::google::protobuf::internal::ArenaStringPtr tag_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* hitpoint_;
			bool active_;
			::google::protobuf::int32 layer_;
			::google::protobuf::int32 instanceid_;
			float fieldofview_;
			float fipd_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<MainCamera> MainCamera_default_instance_;

		// -------------------------------------------------------------------

		class Component : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Component) */ {
		public:
			Component();
			virtual ~Component();

			Component(const Component& from);

			inline Component& operator=(const Component& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const Component& default_instance();

			static const Component* internal_default_instance();

			void Swap(Component* other);

			// implements Message ----------------------------------------------

			inline Component* New() const { return New(NULL); }

			Component* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const Component& from);
			void MergeFrom(const Component& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(Component* other);
			void UnsafeMergeFrom(const Component& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// optional string name = 1;
			bool has_name() const;
			void clear_name();
			static const int kNameFieldNumber = 1;
			const ::std::string& name() const;
			void set_name(const ::std::string& value);
			void set_name(const char* value);
			void set_name(const char* value, size_t size);
			::std::string* mutable_name();
			::std::string* release_name();
			void set_allocated_name(::std::string* name);

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Component)
		private:
			inline void set_has_name();
			inline void clear_has_name();

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			::google::protobuf::internal::ArenaStringPtr name_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<Component> Component_default_instance_;

		// -------------------------------------------------------------------

		class Controller : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Controller) */ {
		public:
			Controller();
			virtual ~Controller();

			Controller(const Controller& from);

			inline Controller& operator=(const Controller& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const Controller& default_instance();

			static const Controller* internal_default_instance();

			void Swap(Controller* other);

			// implements Message ----------------------------------------------

			inline Controller* New() const { return New(NULL); }

			Controller* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const Controller& from);
			void MergeFrom(const Controller& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(Controller* other);
			void UnsafeMergeFrom(const Controller& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// optional string name = 1;
			bool has_name() const;
			void clear_name();
			static const int kNameFieldNumber = 1;
			const ::std::string& name() const;
			void set_name(const ::std::string& value);
			void set_name(const char* value);
			void set_name(const char* value, size_t size);
			::std::string* mutable_name();
			::std::string* release_name();
			void set_allocated_name(::std::string* name);

			// optional bool active = 2;
			bool has_active() const;
			void clear_active();
			static const int kActiveFieldNumber = 2;
			bool active() const;
			void set_active(bool value);

			// optional int32 layer = 3;
			bool has_layer() const;
			void clear_layer();
			static const int kLayerFieldNumber = 3;
			::google::protobuf::int32 layer() const;
			void set_layer(::google::protobuf::int32 value);

			// optional int32 instanceID = 4;
			bool has_instanceid() const;
			void clear_instanceid();
			static const int kInstanceIDFieldNumber = 4;
			::google::protobuf::int32 instanceid() const;
			void set_instanceid(::google::protobuf::int32 value);

			// optional string tag = 5;
			bool has_tag() const;
			void clear_tag();
			static const int kTagFieldNumber = 5;
			const ::std::string& tag() const;
			void set_tag(const ::std::string& value);
			void set_tag(const char* value);
			void set_tag(const char* value, size_t size);
			::std::string* mutable_tag();
			::std::string* release_tag();
			void set_allocated_tag(::std::string* tag);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 6;
			bool has_transform() const;
			void clear_transform();
			static const int kTransformFieldNumber = 6;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& transform() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* mutable_transform();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* release_transform();
			void set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform);

			// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Component list_Component = 7;
			int list_component_size() const;
			void clear_list_component();
			static const int kListComponentFieldNumber = 7;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Component& list_component(int index) const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Component* mutable_list_component(int index);
			::MSAnalyzer::MOSKIT_UNITY_LIB::Component* add_list_component();
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >*
				mutable_list_component();
			const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >&
				list_component() const;

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Controller)
		private:
			inline void set_has_name();
			inline void clear_has_name();
			inline void set_has_active();
			inline void clear_has_active();
			inline void set_has_layer();
			inline void clear_has_layer();
			inline void set_has_instanceid();
			inline void clear_has_instanceid();
			inline void set_has_tag();
			inline void clear_has_tag();
			inline void set_has_transform();
			inline void clear_has_transform();

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component > list_component_;
			::google::protobuf::internal::ArenaStringPtr name_;
			::google::protobuf::internal::ArenaStringPtr tag_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform_;
			bool active_;
			::google::protobuf::int32 layer_;
			::google::protobuf::int32 instanceid_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<Controller> Controller_default_instance_;

		// -------------------------------------------------------------------

		class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Time) */ {
		public:
			Time();
			virtual ~Time();

			Time(const Time& from);

			inline Time& operator=(const Time& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const Time& default_instance();

			static const Time* internal_default_instance();

			void Swap(Time* other);

			// implements Message ----------------------------------------------

			inline Time* New() const { return New(NULL); }

			Time* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const Time& from);
			void MergeFrom(const Time& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(Time* other);
			void UnsafeMergeFrom(const Time& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// optional float deltaTime = 1;
			bool has_deltatime() const;
			void clear_deltatime();
			static const int kDeltaTimeFieldNumber = 1;
			float deltatime() const;
			void set_deltatime(float value);

			// optional int32 frameCount = 2;
			bool has_framecount() const;
			void clear_framecount();
			static const int kFrameCountFieldNumber = 2;
			::google::protobuf::int32 framecount() const;
			void set_framecount(::google::protobuf::int32 value);

			// optional float time = 3;
			bool has_time() const;
			void clear_time();
			static const int kTimeFieldNumber = 3;
			float time() const;
			void set_time(float value);

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Time)
		private:
			inline void set_has_deltatime();
			inline void clear_has_deltatime();
			inline void set_has_framecount();
			inline void clear_has_framecount();
			inline void set_has_time();
			inline void clear_has_time();

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			float deltatime_;
			::google::protobuf::int32 framecount_;
			float time_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<Time> Time_default_instance_;

		// -------------------------------------------------------------------

		class GameObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject) */ {
		public:
			GameObject();
			virtual ~GameObject();

			GameObject(const GameObject& from);

			inline GameObject& operator=(const GameObject& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const GameObject& default_instance();

			static const GameObject* internal_default_instance();

			void Swap(GameObject* other);

			// implements Message ----------------------------------------------

			inline GameObject* New() const { return New(NULL); }

			GameObject* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const GameObject& from);
			void MergeFrom(const GameObject& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(GameObject* other);
			void UnsafeMergeFrom(const GameObject& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// optional string name = 1;
			bool has_name() const;
			void clear_name();
			static const int kNameFieldNumber = 1;
			const ::std::string& name() const;
			void set_name(const ::std::string& value);
			void set_name(const char* value);
			void set_name(const char* value, size_t size);
			::std::string* mutable_name();
			::std::string* release_name();
			void set_allocated_name(::std::string* name);

			// optional bool active = 2;
			bool has_active() const;
			void clear_active();
			static const int kActiveFieldNumber = 2;
			bool active() const;
			void set_active(bool value);

			// optional bool isStatic = 3;
			bool has_isstatic() const;
			void clear_isstatic();
			static const int kIsStaticFieldNumber = 3;
			bool isstatic() const;
			void set_isstatic(bool value);

			// optional int32 layer = 4;
			bool has_layer() const;
			void clear_layer();
			static const int kLayerFieldNumber = 4;
			::google::protobuf::int32 layer() const;
			void set_layer(::google::protobuf::int32 value);

			// optional int32 instanceID = 5;
			bool has_instanceid() const;
			void clear_instanceid();
			static const int kInstanceIDFieldNumber = 5;
			::google::protobuf::int32 instanceid() const;
			void set_instanceid(::google::protobuf::int32 value);

			// optional string tag = 6;
			bool has_tag() const;
			void clear_tag();
			static const int kTagFieldNumber = 6;
			const ::std::string& tag() const;
			void set_tag(const ::std::string& value);
			void set_tag(const char* value);
			void set_tag(const char* value, size_t size);
			::std::string* mutable_tag();
			::std::string* release_tag();
			void set_allocated_tag(::std::string* tag);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 7;
			bool has_transform() const;
			void clear_transform();
			static const int kTransformFieldNumber = 7;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& transform() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* mutable_transform();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* release_transform();
			void set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform);

			// optional string strType = 8;
			bool has_strtype() const;
			void clear_strtype();
			static const int kStrTypeFieldNumber = 8;
			const ::std::string& strtype() const;
			void set_strtype(const ::std::string& value);
			void set_strtype(const char* value);
			void set_strtype(const char* value, size_t size);
			::std::string* mutable_strtype();
			::std::string* release_strtype();
			void set_allocated_strtype(::std::string* strtype);

			// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Component list_Component = 9;
			int list_component_size() const;
			void clear_list_component();
			static const int kListComponentFieldNumber = 9;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Component& list_component(int index) const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Component* mutable_list_component(int index);
			::MSAnalyzer::MOSKIT_UNITY_LIB::Component* add_list_component();
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >*
				mutable_list_component();
			const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >&
				list_component() const;

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject)
		private:
			inline void set_has_name();
			inline void clear_has_name();
			inline void set_has_active();
			inline void clear_has_active();
			inline void set_has_isstatic();
			inline void clear_has_isstatic();
			inline void set_has_layer();
			inline void clear_has_layer();
			inline void set_has_instanceid();
			inline void clear_has_instanceid();
			inline void set_has_tag();
			inline void clear_has_tag();
			inline void set_has_transform();
			inline void clear_has_transform();
			inline void set_has_strtype();
			inline void clear_has_strtype();

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component > list_component_;
			::google::protobuf::internal::ArenaStringPtr name_;
			::google::protobuf::internal::ArenaStringPtr tag_;
			::google::protobuf::internal::ArenaStringPtr strtype_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform_;
			bool active_;
			bool isstatic_;
			::google::protobuf::int32 layer_;
			::google::protobuf::int32 instanceid_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<GameObject> GameObject_default_instance_;

		// -------------------------------------------------------------------

		class Scene : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Scene) */ {
		public:
			Scene();
			virtual ~Scene();

			Scene(const Scene& from);

			inline Scene& operator=(const Scene& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const Scene& default_instance();

			static const Scene* internal_default_instance();

			void Swap(Scene* other);

			// implements Message ----------------------------------------------

			inline Scene* New() const { return New(NULL); }

			Scene* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const Scene& from);
			void MergeFrom(const Scene& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(Scene* other);
			void UnsafeMergeFrom(const Scene& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// optional string strIndicate = 1;
			bool has_strindicate() const;
			void clear_strindicate();
			static const int kStrIndicateFieldNumber = 1;
			const ::std::string& strindicate() const;
			void set_strindicate(const ::std::string& value);
			void set_strindicate(const char* value);
			void set_strindicate(const char* value, size_t size);
			::std::string* mutable_strindicate();
			::std::string* release_strindicate();
			void set_allocated_strindicate(::std::string* strindicate);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Time time = 2;
			bool has_time() const;
			void clear_time();
			static const int kTimeFieldNumber = 2;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Time& time() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Time* mutable_time();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Time* release_time();
			void set_allocated_time(::MSAnalyzer::MOSKIT_UNITY_LIB::Time* time);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera Camera = 3;
			bool has_camera() const;
			void clear_camera();
			static const int kCameraFieldNumber = 3;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera& camera() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* mutable_camera();
			::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* release_camera();
			void set_allocated_camera(::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* camera);

			// optional float fScaleRatio = 4;
			bool has_fscaleratio() const;
			void clear_fscaleratio();
			static const int kFScaleRatioFieldNumber = 4;
			float fscaleratio() const;
			void set_fscaleratio(float value);

			// optional bool bVSync = 5;
			bool has_bvsync() const;
			void clear_bvsync();
			static const int kBVSyncFieldNumber = 5;
			bool bvsync() const;
			void set_bvsync(bool value);

			// optional .MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer Analysis_Buffer = 6;
			bool has_analysis_buffer() const;
			void clear_analysis_buffer();
			static const int kAnalysisBufferFieldNumber = 6;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer& analysis_buffer() const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer* mutable_analysis_buffer();
			::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer* release_analysis_buffer();
			void set_allocated_analysis_buffer(::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer* analysis_buffer);

			// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Controller list_Controller = 7;
			int list_controller_size() const;
			void clear_list_controller();
			static const int kListControllerFieldNumber = 7;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller& list_controller(int index) const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Controller* mutable_list_controller(int index);
			::MSAnalyzer::MOSKIT_UNITY_LIB::Controller* add_list_controller();
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller >*
				mutable_list_controller();
			const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller >&
				list_controller() const;

			// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.GameObject list_gameObject = 8;
			int list_gameobject_size() const;
			void clear_list_gameobject();
			static const int kListGameObjectFieldNumber = 8;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject& list_gameobject(int index) const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* mutable_list_gameobject(int index);
			::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* add_list_gameobject();
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >*
				mutable_list_gameobject();
			const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >&
				list_gameobject() const;

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Scene)
		private:
			inline void set_has_strindicate();
			inline void clear_has_strindicate();
			inline void set_has_time();
			inline void clear_has_time();
			inline void set_has_camera();
			inline void clear_has_camera();
			inline void set_has_fscaleratio();
			inline void clear_has_fscaleratio();
			inline void set_has_bvsync();
			inline void clear_has_bvsync();
			inline void set_has_analysis_buffer();
			inline void clear_has_analysis_buffer();

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller > list_controller_;
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject > list_gameobject_;
			::google::protobuf::internal::ArenaStringPtr strindicate_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Time* time_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* camera_;
			::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer* analysis_buffer_;
			float fscaleratio_;
			bool bvsync_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<Scene> Scene_default_instance_;

		// -------------------------------------------------------------------

		class ArrayScene : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene) */ {
		public:
			ArrayScene();
			virtual ~ArrayScene();

			ArrayScene(const ArrayScene& from);

			inline ArrayScene& operator=(const ArrayScene& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const ArrayScene& default_instance();

			static const ArrayScene* internal_default_instance();

			void Swap(ArrayScene* other);

			// implements Message ----------------------------------------------

			inline ArrayScene* New() const { return New(NULL); }

			ArrayScene* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const ArrayScene& from);
			void MergeFrom(const ArrayScene& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(ArrayScene* other);
			void UnsafeMergeFrom(const ArrayScene& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Scene list_Scene = 1;
			int list_scene_size() const;
			void clear_list_scene();
			static const int kListSceneFieldNumber = 1;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene& list_scene(int index) const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Scene* mutable_list_scene(int index);
			::MSAnalyzer::MOSKIT_UNITY_LIB::Scene* add_list_scene();
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene >*
				mutable_list_scene();
			const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene >&
				list_scene() const;

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene)
		private:

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene > list_scene_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<ArrayScene> ArrayScene_default_instance_;

		// -------------------------------------------------------------------

		class AnalysisBuffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer) */ {
		public:
			AnalysisBuffer();
			virtual ~AnalysisBuffer();

			AnalysisBuffer(const AnalysisBuffer& from);

			inline AnalysisBuffer& operator=(const AnalysisBuffer& from) {
				CopyFrom(from);
				return *this;
			}

			inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
				return _internal_metadata_.unknown_fields();
			}

			inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
				return _internal_metadata_.mutable_unknown_fields();
			}

			static const ::google::protobuf::Descriptor* descriptor();
			static const AnalysisBuffer& default_instance();

			static const AnalysisBuffer* internal_default_instance();

			void Swap(AnalysisBuffer* other);

			// implements Message ----------------------------------------------

			inline AnalysisBuffer* New() const { return New(NULL); }

			AnalysisBuffer* New(::google::protobuf::Arena* arena) const;
			void CopyFrom(const ::google::protobuf::Message& from);
			void MergeFrom(const ::google::protobuf::Message& from);
			void CopyFrom(const AnalysisBuffer& from);
			void MergeFrom(const AnalysisBuffer& from);
			void Clear();
			bool IsInitialized() const;

			size_t ByteSizeLong() const;
			bool MergePartialFromCodedStream(
				::google::protobuf::io::CodedInputStream* input);
			void SerializeWithCachedSizes(
				::google::protobuf::io::CodedOutputStream* output) const;
			::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
				bool deterministic, ::google::protobuf::uint8* output) const;
			::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
				return InternalSerializeWithCachedSizesToArray(false, output);
			}
			int GetCachedSize() const { return _cached_size_; }
		private:
			void SharedCtor();
			void SharedDtor();
			void SetCachedSize(int size) const;
			void InternalSwap(AnalysisBuffer* other);
			void UnsafeMergeFrom(const AnalysisBuffer& from);
		private:
			inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
				return _internal_metadata_.arena();
			}
			inline void* MaybeArenaPtr() const {
				return _internal_metadata_.raw_arena_ptr();
			}
		public:

			::google::protobuf::Metadata GetMetadata() const;

			// nested types ----------------------------------------------------

			// accessors -------------------------------------------------------

			// repeated int32 list_Int = 1;
			int list_int_size() const;
			void clear_list_int();
			static const int kListIntFieldNumber = 1;
			::google::protobuf::int32 list_int(int index) const;
			void set_list_int(int index, ::google::protobuf::int32 value);
			void add_list_int(::google::protobuf::int32 value);
			const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
				list_int() const;
			::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
				mutable_list_int();

			// repeated float list_Float = 2;
			int list_float_size() const;
			void clear_list_float();
			static const int kListFloatFieldNumber = 2;
			float list_float(int index) const;
			void set_list_float(int index, float value);
			void add_list_float(float value);
			const ::google::protobuf::RepeatedField< float >&
				list_float() const;
			::google::protobuf::RepeatedField< float >*
				mutable_list_float();

			// repeated string list_String = 3;
			int list_string_size() const;
			void clear_list_string();
			static const int kListStringFieldNumber = 3;
			const ::std::string& list_string(int index) const;
			::std::string* mutable_list_string(int index);
			void set_list_string(int index, const ::std::string& value);
			void set_list_string(int index, const char* value);
			void set_list_string(int index, const char* value, size_t size);
			::std::string* add_list_string();
			void add_list_string(const ::std::string& value);
			void add_list_string(const char* value);
			void add_list_string(const char* value, size_t size);
			const ::google::protobuf::RepeatedPtrField< ::std::string>& list_string() const;
			::google::protobuf::RepeatedPtrField< ::std::string>* mutable_list_string();

			// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 list_Vector3 = 4;
			int list_vector3_size() const;
			void clear_list_vector3();
			static const int kListVector3FieldNumber = 4;
			const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& list_vector3(int index) const;
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_list_vector3(int index);
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* add_list_vector3();
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3 >*
				mutable_list_vector3();
			const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3 >&
				list_vector3() const;

			// @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer)
		private:

			::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
			::google::protobuf::internal::HasBits<1> _has_bits_;
			mutable int _cached_size_;
			::google::protobuf::RepeatedField< ::google::protobuf::int32 > list_int_;
			::google::protobuf::RepeatedField< float > list_float_;
			::google::protobuf::RepeatedPtrField< ::std::string> list_string_;
			::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3 > list_vector3_;
			friend void  protobuf_InitDefaults_moskit_2eproto_impl();
			friend void  protobuf_AddDesc_moskit_2eproto_impl();
			friend void protobuf_AssignDesc_moskit_2eproto();
			friend void protobuf_ShutdownFile_moskit_2eproto();

			void InitAsDefaultInstance();
		};
		extern ::google::protobuf::internal::ExplicitlyConstructed<AnalysisBuffer> AnalysisBuffer_default_instance_;

		// ===================================================================


		// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
		// Vector3

		// optional float x = 1;
		inline bool Vector3::has_x() const {
			return (_has_bits_[0] & 0x00000001u) != 0;
		}
		inline void Vector3::set_has_x() {
			_has_bits_[0] |= 0x00000001u;
		}
		inline void Vector3::clear_has_x() {
			_has_bits_[0] &= ~0x00000001u;
		}
		inline void Vector3::clear_x() {
			x_ = 0;
			clear_has_x();
		}
		inline float Vector3::x() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.x)
			return x_;
		}
		inline void Vector3::set_x(float value) {
			set_has_x();
			x_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.x)
		}

		// optional float y = 2;
		inline bool Vector3::has_y() const {
			return (_has_bits_[0] & 0x00000002u) != 0;
		}
		inline void Vector3::set_has_y() {
			_has_bits_[0] |= 0x00000002u;
		}
		inline void Vector3::clear_has_y() {
			_has_bits_[0] &= ~0x00000002u;
		}
		inline void Vector3::clear_y() {
			y_ = 0;
			clear_has_y();
		}
		inline float Vector3::y() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.y)
			return y_;
		}
		inline void Vector3::set_y(float value) {
			set_has_y();
			y_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.y)
		}

		// optional float z = 3;
		inline bool Vector3::has_z() const {
			return (_has_bits_[0] & 0x00000004u) != 0;
		}
		inline void Vector3::set_has_z() {
			_has_bits_[0] |= 0x00000004u;
		}
		inline void Vector3::clear_has_z() {
			_has_bits_[0] &= ~0x00000004u;
		}
		inline void Vector3::clear_z() {
			z_ = 0;
			clear_has_z();
		}
		inline float Vector3::z() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.z)
			return z_;
		}
		inline void Vector3::set_z(float value) {
			set_has_z();
			z_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.z)
		}

		inline const Vector3* Vector3::internal_default_instance() {
			return &Vector3_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// Transform

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 eulerAngles = 1;
		inline bool Transform::has_eulerangles() const {
			return (_has_bits_[0] & 0x00000001u) != 0;
		}
		inline void Transform::set_has_eulerangles() {
			_has_bits_[0] |= 0x00000001u;
		}
		inline void Transform::clear_has_eulerangles() {
			_has_bits_[0] &= ~0x00000001u;
		}
		inline void Transform::clear_eulerangles() {
			if (eulerangles_ != NULL) eulerangles_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
			clear_has_eulerangles();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::eulerangles() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.eulerAngles)
			return eulerangles_ != NULL ? *eulerangles_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_eulerangles() {
			set_has_eulerangles();
			if (eulerangles_ == NULL) {
				eulerangles_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.eulerAngles)
			return eulerangles_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_eulerangles() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.eulerAngles)
			clear_has_eulerangles();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = eulerangles_;
			eulerangles_ = NULL;
			return temp;
		}
		inline void Transform::set_allocated_eulerangles(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* eulerangles) {
			delete eulerangles_;
			eulerangles_ = eulerangles;
			if (eulerangles) {
				set_has_eulerangles();
			}
			else {
				clear_has_eulerangles();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.eulerAngles)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 position = 2;
		inline bool Transform::has_position() const {
			return (_has_bits_[0] & 0x00000002u) != 0;
		}
		inline void Transform::set_has_position() {
			_has_bits_[0] |= 0x00000002u;
		}
		inline void Transform::clear_has_position() {
			_has_bits_[0] &= ~0x00000002u;
		}
		inline void Transform::clear_position() {
			if (position_ != NULL) position_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
			clear_has_position();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::position() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.position)
			return position_ != NULL ? *position_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_position() {
			set_has_position();
			if (position_ == NULL) {
				position_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.position)
			return position_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_position() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.position)
			clear_has_position();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = position_;
			position_ = NULL;
			return temp;
		}
		inline void Transform::set_allocated_position(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* position) {
			delete position_;
			position_ = position;
			if (position) {
				set_has_position();
			}
			else {
				clear_has_position();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.position)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 angularVelocity = 3;
		inline bool Transform::has_angularvelocity() const {
			return (_has_bits_[0] & 0x00000004u) != 0;
		}
		inline void Transform::set_has_angularvelocity() {
			_has_bits_[0] |= 0x00000004u;
		}
		inline void Transform::clear_has_angularvelocity() {
			_has_bits_[0] &= ~0x00000004u;
		}
		inline void Transform::clear_angularvelocity() {
			if (angularvelocity_ != NULL) angularvelocity_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
			clear_has_angularvelocity();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::angularvelocity() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.angularVelocity)
			return angularvelocity_ != NULL ? *angularvelocity_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_angularvelocity() {
			set_has_angularvelocity();
			if (angularvelocity_ == NULL) {
				angularvelocity_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.angularVelocity)
			return angularvelocity_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_angularvelocity() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.angularVelocity)
			clear_has_angularvelocity();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = angularvelocity_;
			angularvelocity_ = NULL;
			return temp;
		}
		inline void Transform::set_allocated_angularvelocity(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* angularvelocity) {
			delete angularvelocity_;
			angularvelocity_ = angularvelocity;
			if (angularvelocity) {
				set_has_angularvelocity();
			}
			else {
				clear_has_angularvelocity();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.angularVelocity)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 scale = 4;
		inline bool Transform::has_scale() const {
			return (_has_bits_[0] & 0x00000008u) != 0;
		}
		inline void Transform::set_has_scale() {
			_has_bits_[0] |= 0x00000008u;
		}
		inline void Transform::clear_has_scale() {
			_has_bits_[0] &= ~0x00000008u;
		}
		inline void Transform::clear_scale() {
			if (scale_ != NULL) scale_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
			clear_has_scale();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::scale() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.scale)
			return scale_ != NULL ? *scale_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_scale() {
			set_has_scale();
			if (scale_ == NULL) {
				scale_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.scale)
			return scale_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_scale() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.scale)
			clear_has_scale();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = scale_;
			scale_ = NULL;
			return temp;
		}
		inline void Transform::set_allocated_scale(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* scale) {
			delete scale_;
			scale_ = scale;
			if (scale) {
				set_has_scale();
			}
			else {
				clear_has_scale();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.scale)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 forward = 5;
		inline bool Transform::has_forward() const {
			return (_has_bits_[0] & 0x00000010u) != 0;
		}
		inline void Transform::set_has_forward() {
			_has_bits_[0] |= 0x00000010u;
		}
		inline void Transform::clear_has_forward() {
			_has_bits_[0] &= ~0x00000010u;
		}
		inline void Transform::clear_forward() {
			if (forward_ != NULL) forward_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
			clear_has_forward();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::forward() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.forward)
			return forward_ != NULL ? *forward_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_forward() {
			set_has_forward();
			if (forward_ == NULL) {
				forward_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.forward)
			return forward_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_forward() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.forward)
			clear_has_forward();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = forward_;
			forward_ = NULL;
			return temp;
		}
		inline void Transform::set_allocated_forward(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* forward) {
			delete forward_;
			forward_ = forward;
			if (forward) {
				set_has_forward();
			}
			else {
				clear_has_forward();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.forward)
		}

		// optional int32 parent = 6;
		inline bool Transform::has_parent() const {
			return (_has_bits_[0] & 0x00000020u) != 0;
		}
		inline void Transform::set_has_parent() {
			_has_bits_[0] |= 0x00000020u;
		}
		inline void Transform::clear_has_parent() {
			_has_bits_[0] &= ~0x00000020u;
		}
		inline void Transform::clear_parent() {
			parent_ = 0;
			clear_has_parent();
		}
		inline ::google::protobuf::int32 Transform::parent() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.parent)
			return parent_;
		}
		inline void Transform::set_parent(::google::protobuf::int32 value) {
			set_has_parent();
			parent_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.parent)
		}

		inline const Transform* Transform::internal_default_instance() {
			return &Transform_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// MainCamera

		// optional string name = 1;
		inline bool MainCamera::has_name() const {
			return (_has_bits_[0] & 0x00000001u) != 0;
		}
		inline void MainCamera::set_has_name() {
			_has_bits_[0] |= 0x00000001u;
		}
		inline void MainCamera::clear_has_name() {
			_has_bits_[0] &= ~0x00000001u;
		}
		inline void MainCamera::clear_name() {
			name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_name();
		}
		inline const ::std::string& MainCamera::name() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
			return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void MainCamera::set_name(const ::std::string& value) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
		}
		inline void MainCamera::set_name(const char* value) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
		}
		inline void MainCamera::set_name(const char* value, size_t size) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
		}
		inline ::std::string* MainCamera::mutable_name() {
			set_has_name();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
			return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* MainCamera::release_name() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
			clear_has_name();
			return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void MainCamera::set_allocated_name(::std::string* name) {
			if (name != NULL) {
				set_has_name();
			}
			else {
				clear_has_name();
			}
			name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
		}

		// optional bool active = 2;
		inline bool MainCamera::has_active() const {
			return (_has_bits_[0] & 0x00000002u) != 0;
		}
		inline void MainCamera::set_has_active() {
			_has_bits_[0] |= 0x00000002u;
		}
		inline void MainCamera::clear_has_active() {
			_has_bits_[0] &= ~0x00000002u;
		}
		inline void MainCamera::clear_active() {
			active_ = false;
			clear_has_active();
		}
		inline bool MainCamera::active() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.active)
			return active_;
		}
		inline void MainCamera::set_active(bool value) {
			set_has_active();
			active_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.active)
		}

		// optional int32 layer = 3;
		inline bool MainCamera::has_layer() const {
			return (_has_bits_[0] & 0x00000004u) != 0;
		}
		inline void MainCamera::set_has_layer() {
			_has_bits_[0] |= 0x00000004u;
		}
		inline void MainCamera::clear_has_layer() {
			_has_bits_[0] &= ~0x00000004u;
		}
		inline void MainCamera::clear_layer() {
			layer_ = 0;
			clear_has_layer();
		}
		inline ::google::protobuf::int32 MainCamera::layer() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.layer)
			return layer_;
		}
		inline void MainCamera::set_layer(::google::protobuf::int32 value) {
			set_has_layer();
			layer_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.layer)
		}

		// optional int32 instanceID = 4;
		inline bool MainCamera::has_instanceid() const {
			return (_has_bits_[0] & 0x00000008u) != 0;
		}
		inline void MainCamera::set_has_instanceid() {
			_has_bits_[0] |= 0x00000008u;
		}
		inline void MainCamera::clear_has_instanceid() {
			_has_bits_[0] &= ~0x00000008u;
		}
		inline void MainCamera::clear_instanceid() {
			instanceid_ = 0;
			clear_has_instanceid();
		}
		inline ::google::protobuf::int32 MainCamera::instanceid() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.instanceID)
			return instanceid_;
		}
		inline void MainCamera::set_instanceid(::google::protobuf::int32 value) {
			set_has_instanceid();
			instanceid_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.instanceID)
		}

		// optional string tag = 5;
		inline bool MainCamera::has_tag() const {
			return (_has_bits_[0] & 0x00000010u) != 0;
		}
		inline void MainCamera::set_has_tag() {
			_has_bits_[0] |= 0x00000010u;
		}
		inline void MainCamera::clear_has_tag() {
			_has_bits_[0] &= ~0x00000010u;
		}
		inline void MainCamera::clear_tag() {
			tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_tag();
		}
		inline const ::std::string& MainCamera::tag() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
			return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void MainCamera::set_tag(const ::std::string& value) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
		}
		inline void MainCamera::set_tag(const char* value) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
		}
		inline void MainCamera::set_tag(const char* value, size_t size) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
		}
		inline ::std::string* MainCamera::mutable_tag() {
			set_has_tag();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
			return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* MainCamera::release_tag() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
			clear_has_tag();
			return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void MainCamera::set_allocated_tag(::std::string* tag) {
			if (tag != NULL) {
				set_has_tag();
			}
			else {
				clear_has_tag();
			}
			tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
		}

		// optional float FieldOfView = 6;
		inline bool MainCamera::has_fieldofview() const {
			return (_has_bits_[0] & 0x00000020u) != 0;
		}
		inline void MainCamera::set_has_fieldofview() {
			_has_bits_[0] |= 0x00000020u;
		}
		inline void MainCamera::clear_has_fieldofview() {
			_has_bits_[0] &= ~0x00000020u;
		}
		inline void MainCamera::clear_fieldofview() {
			fieldofview_ = 0;
			clear_has_fieldofview();
		}
		inline float MainCamera::fieldofview() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.FieldOfView)
			return fieldofview_;
		}
		inline void MainCamera::set_fieldofview(float value) {
			set_has_fieldofview();
			fieldofview_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.FieldOfView)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 7;
		inline bool MainCamera::has_transform() const {
			return (_has_bits_[0] & 0x00000040u) != 0;
		}
		inline void MainCamera::set_has_transform() {
			_has_bits_[0] |= 0x00000040u;
		}
		inline void MainCamera::clear_has_transform() {
			_has_bits_[0] &= ~0x00000040u;
		}
		inline void MainCamera::clear_transform() {
			if (transform_ != NULL) transform_->::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::Clear();
			clear_has_transform();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& MainCamera::transform() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.transform)
			return transform_ != NULL ? *transform_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* MainCamera::mutable_transform() {
			set_has_transform();
			if (transform_ == NULL) {
				transform_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.transform)
			return transform_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* MainCamera::release_transform() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.transform)
			clear_has_transform();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* temp = transform_;
			transform_ = NULL;
			return temp;
		}
		inline void MainCamera::set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform) {
			delete transform_;
			transform_ = transform;
			if (transform) {
				set_has_transform();
			}
			else {
				clear_has_transform();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.transform)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 hitpoint = 8;
		inline bool MainCamera::has_hitpoint() const {
			return (_has_bits_[0] & 0x00000080u) != 0;
		}
		inline void MainCamera::set_has_hitpoint() {
			_has_bits_[0] |= 0x00000080u;
		}
		inline void MainCamera::clear_has_hitpoint() {
			_has_bits_[0] &= ~0x00000080u;
		}
		inline void MainCamera::clear_hitpoint() {
			if (hitpoint_ != NULL) hitpoint_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
			clear_has_hitpoint();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& MainCamera::hitpoint() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.hitpoint)
			return hitpoint_ != NULL ? *hitpoint_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* MainCamera::mutable_hitpoint() {
			set_has_hitpoint();
			if (hitpoint_ == NULL) {
				hitpoint_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.hitpoint)
			return hitpoint_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* MainCamera::release_hitpoint() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.hitpoint)
			clear_has_hitpoint();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = hitpoint_;
			hitpoint_ = NULL;
			return temp;
		}
		inline void MainCamera::set_allocated_hitpoint(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* hitpoint) {
			delete hitpoint_;
			hitpoint_ = hitpoint;
			if (hitpoint) {
				set_has_hitpoint();
			}
			else {
				clear_has_hitpoint();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.hitpoint)
		}

		// optional float fIPD = 9;
		inline bool MainCamera::has_fipd() const {
			return (_has_bits_[0] & 0x00000100u) != 0;
		}
		inline void MainCamera::set_has_fipd() {
			_has_bits_[0] |= 0x00000100u;
		}
		inline void MainCamera::clear_has_fipd() {
			_has_bits_[0] &= ~0x00000100u;
		}
		inline void MainCamera::clear_fipd() {
			fipd_ = 0;
			clear_has_fipd();
		}
		inline float MainCamera::fipd() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.fIPD)
			return fipd_;
		}
		inline void MainCamera::set_fipd(float value) {
			set_has_fipd();
			fipd_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.fIPD)
		}

		// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Component list_Component = 10;
		inline int MainCamera::list_component_size() const {
			return list_component_.size();
		}
		inline void MainCamera::clear_list_component() {
			list_component_.Clear();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Component& MainCamera::list_component(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.list_Component)
			return list_component_.Get(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Component* MainCamera::mutable_list_component(int index) {
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.list_Component)
			return list_component_.Mutable(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Component* MainCamera::add_list_component() {
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.list_Component)
			return list_component_.Add();
		}
		inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >*
			MainCamera::mutable_list_component() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.list_Component)
			return &list_component_;
		}
		inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >&
			MainCamera::list_component() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.list_Component)
			return list_component_;
		}

		inline const MainCamera* MainCamera::internal_default_instance() {
			return &MainCamera_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// Component

		// optional string name = 1;
		inline bool Component::has_name() const {
			return (_has_bits_[0] & 0x00000001u) != 0;
		}
		inline void Component::set_has_name() {
			_has_bits_[0] |= 0x00000001u;
		}
		inline void Component::clear_has_name() {
			_has_bits_[0] &= ~0x00000001u;
		}
		inline void Component::clear_name() {
			name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_name();
		}
		inline const ::std::string& Component::name() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Component.name)
			return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void Component::set_name(const ::std::string& value) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Component.name)
		}
		inline void Component::set_name(const char* value) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.Component.name)
		}
		inline void Component::set_name(const char* value, size_t size) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.Component.name)
		}
		inline ::std::string* Component::mutable_name() {
			set_has_name();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Component.name)
			return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* Component::release_name() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Component.name)
			clear_has_name();
			return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void Component::set_allocated_name(::std::string* name) {
			if (name != NULL) {
				set_has_name();
			}
			else {
				clear_has_name();
			}
			name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Component.name)
		}

		inline const Component* Component::internal_default_instance() {
			return &Component_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// Controller

		// optional string name = 1;
		inline bool Controller::has_name() const {
			return (_has_bits_[0] & 0x00000001u) != 0;
		}
		inline void Controller::set_has_name() {
			_has_bits_[0] |= 0x00000001u;
		}
		inline void Controller::clear_has_name() {
			_has_bits_[0] &= ~0x00000001u;
		}
		inline void Controller::clear_name() {
			name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_name();
		}
		inline const ::std::string& Controller::name() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.name)
			return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void Controller::set_name(const ::std::string& value) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.name)
		}
		inline void Controller::set_name(const char* value) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.name)
		}
		inline void Controller::set_name(const char* value, size_t size) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.name)
		}
		inline ::std::string* Controller::mutable_name() {
			set_has_name();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.name)
			return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* Controller::release_name() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.name)
			clear_has_name();
			return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void Controller::set_allocated_name(::std::string* name) {
			if (name != NULL) {
				set_has_name();
			}
			else {
				clear_has_name();
			}
			name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.name)
		}

		// optional bool active = 2;
		inline bool Controller::has_active() const {
			return (_has_bits_[0] & 0x00000002u) != 0;
		}
		inline void Controller::set_has_active() {
			_has_bits_[0] |= 0x00000002u;
		}
		inline void Controller::clear_has_active() {
			_has_bits_[0] &= ~0x00000002u;
		}
		inline void Controller::clear_active() {
			active_ = false;
			clear_has_active();
		}
		inline bool Controller::active() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.active)
			return active_;
		}
		inline void Controller::set_active(bool value) {
			set_has_active();
			active_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.active)
		}

		// optional int32 layer = 3;
		inline bool Controller::has_layer() const {
			return (_has_bits_[0] & 0x00000004u) != 0;
		}
		inline void Controller::set_has_layer() {
			_has_bits_[0] |= 0x00000004u;
		}
		inline void Controller::clear_has_layer() {
			_has_bits_[0] &= ~0x00000004u;
		}
		inline void Controller::clear_layer() {
			layer_ = 0;
			clear_has_layer();
		}
		inline ::google::protobuf::int32 Controller::layer() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.layer)
			return layer_;
		}
		inline void Controller::set_layer(::google::protobuf::int32 value) {
			set_has_layer();
			layer_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.layer)
		}

		// optional int32 instanceID = 4;
		inline bool Controller::has_instanceid() const {
			return (_has_bits_[0] & 0x00000008u) != 0;
		}
		inline void Controller::set_has_instanceid() {
			_has_bits_[0] |= 0x00000008u;
		}
		inline void Controller::clear_has_instanceid() {
			_has_bits_[0] &= ~0x00000008u;
		}
		inline void Controller::clear_instanceid() {
			instanceid_ = 0;
			clear_has_instanceid();
		}
		inline ::google::protobuf::int32 Controller::instanceid() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.instanceID)
			return instanceid_;
		}
		inline void Controller::set_instanceid(::google::protobuf::int32 value) {
			set_has_instanceid();
			instanceid_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.instanceID)
		}

		// optional string tag = 5;
		inline bool Controller::has_tag() const {
			return (_has_bits_[0] & 0x00000010u) != 0;
		}
		inline void Controller::set_has_tag() {
			_has_bits_[0] |= 0x00000010u;
		}
		inline void Controller::clear_has_tag() {
			_has_bits_[0] &= ~0x00000010u;
		}
		inline void Controller::clear_tag() {
			tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_tag();
		}
		inline const ::std::string& Controller::tag() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.tag)
			return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void Controller::set_tag(const ::std::string& value) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.tag)
		}
		inline void Controller::set_tag(const char* value) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.tag)
		}
		inline void Controller::set_tag(const char* value, size_t size) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.tag)
		}
		inline ::std::string* Controller::mutable_tag() {
			set_has_tag();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.tag)
			return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* Controller::release_tag() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.tag)
			clear_has_tag();
			return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void Controller::set_allocated_tag(::std::string* tag) {
			if (tag != NULL) {
				set_has_tag();
			}
			else {
				clear_has_tag();
			}
			tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.tag)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 6;
		inline bool Controller::has_transform() const {
			return (_has_bits_[0] & 0x00000020u) != 0;
		}
		inline void Controller::set_has_transform() {
			_has_bits_[0] |= 0x00000020u;
		}
		inline void Controller::clear_has_transform() {
			_has_bits_[0] &= ~0x00000020u;
		}
		inline void Controller::clear_transform() {
			if (transform_ != NULL) transform_->::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::Clear();
			clear_has_transform();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& Controller::transform() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.transform)
			return transform_ != NULL ? *transform_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* Controller::mutable_transform() {
			set_has_transform();
			if (transform_ == NULL) {
				transform_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.transform)
			return transform_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* Controller::release_transform() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.transform)
			clear_has_transform();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* temp = transform_;
			transform_ = NULL;
			return temp;
		}
		inline void Controller::set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform) {
			delete transform_;
			transform_ = transform;
			if (transform) {
				set_has_transform();
			}
			else {
				clear_has_transform();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.transform)
		}

		// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Component list_Component = 7;
		inline int Controller::list_component_size() const {
			return list_component_.size();
		}
		inline void Controller::clear_list_component() {
			list_component_.Clear();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Component& Controller::list_component(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.list_Component)
			return list_component_.Get(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Component* Controller::mutable_list_component(int index) {
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.list_Component)
			return list_component_.Mutable(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Component* Controller::add_list_component() {
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.list_Component)
			return list_component_.Add();
		}
		inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >*
			Controller::mutable_list_component() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.list_Component)
			return &list_component_;
		}
		inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >&
			Controller::list_component() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.Controller.list_Component)
			return list_component_;
		}

		inline const Controller* Controller::internal_default_instance() {
			return &Controller_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// Time

		// optional float deltaTime = 1;
		inline bool Time::has_deltatime() const {
			return (_has_bits_[0] & 0x00000001u) != 0;
		}
		inline void Time::set_has_deltatime() {
			_has_bits_[0] |= 0x00000001u;
		}
		inline void Time::clear_has_deltatime() {
			_has_bits_[0] &= ~0x00000001u;
		}
		inline void Time::clear_deltatime() {
			deltatime_ = 0;
			clear_has_deltatime();
		}
		inline float Time::deltatime() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Time.deltaTime)
			return deltatime_;
		}
		inline void Time::set_deltatime(float value) {
			set_has_deltatime();
			deltatime_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Time.deltaTime)
		}

		// optional int32 frameCount = 2;
		inline bool Time::has_framecount() const {
			return (_has_bits_[0] & 0x00000002u) != 0;
		}
		inline void Time::set_has_framecount() {
			_has_bits_[0] |= 0x00000002u;
		}
		inline void Time::clear_has_framecount() {
			_has_bits_[0] &= ~0x00000002u;
		}
		inline void Time::clear_framecount() {
			framecount_ = 0;
			clear_has_framecount();
		}
		inline ::google::protobuf::int32 Time::framecount() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Time.frameCount)
			return framecount_;
		}
		inline void Time::set_framecount(::google::protobuf::int32 value) {
			set_has_framecount();
			framecount_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Time.frameCount)
		}

		// optional float time = 3;
		inline bool Time::has_time() const {
			return (_has_bits_[0] & 0x00000004u) != 0;
		}
		inline void Time::set_has_time() {
			_has_bits_[0] |= 0x00000004u;
		}
		inline void Time::clear_has_time() {
			_has_bits_[0] &= ~0x00000004u;
		}
		inline void Time::clear_time() {
			time_ = 0;
			clear_has_time();
		}
		inline float Time::time() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Time.time)
			return time_;
		}
		inline void Time::set_time(float value) {
			set_has_time();
			time_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Time.time)
		}

		inline const Time* Time::internal_default_instance() {
			return &Time_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// GameObject

		// optional string name = 1;
		inline bool GameObject::has_name() const {
			return (_has_bits_[0] & 0x00000001u) != 0;
		}
		inline void GameObject::set_has_name() {
			_has_bits_[0] |= 0x00000001u;
		}
		inline void GameObject::clear_has_name() {
			_has_bits_[0] &= ~0x00000001u;
		}
		inline void GameObject::clear_name() {
			name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_name();
		}
		inline const ::std::string& GameObject::name() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
			return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void GameObject::set_name(const ::std::string& value) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
		}
		inline void GameObject::set_name(const char* value) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
		}
		inline void GameObject::set_name(const char* value, size_t size) {
			set_has_name();
			name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
		}
		inline ::std::string* GameObject::mutable_name() {
			set_has_name();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
			return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* GameObject::release_name() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
			clear_has_name();
			return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void GameObject::set_allocated_name(::std::string* name) {
			if (name != NULL) {
				set_has_name();
			}
			else {
				clear_has_name();
			}
			name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
		}

		// optional bool active = 2;
		inline bool GameObject::has_active() const {
			return (_has_bits_[0] & 0x00000002u) != 0;
		}
		inline void GameObject::set_has_active() {
			_has_bits_[0] |= 0x00000002u;
		}
		inline void GameObject::clear_has_active() {
			_has_bits_[0] &= ~0x00000002u;
		}
		inline void GameObject::clear_active() {
			active_ = false;
			clear_has_active();
		}
		inline bool GameObject::active() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.active)
			return active_;
		}
		inline void GameObject::set_active(bool value) {
			set_has_active();
			active_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.active)
		}

		// optional bool isStatic = 3;
		inline bool GameObject::has_isstatic() const {
			return (_has_bits_[0] & 0x00000004u) != 0;
		}
		inline void GameObject::set_has_isstatic() {
			_has_bits_[0] |= 0x00000004u;
		}
		inline void GameObject::clear_has_isstatic() {
			_has_bits_[0] &= ~0x00000004u;
		}
		inline void GameObject::clear_isstatic() {
			isstatic_ = false;
			clear_has_isstatic();
		}
		inline bool GameObject::isstatic() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.isStatic)
			return isstatic_;
		}
		inline void GameObject::set_isstatic(bool value) {
			set_has_isstatic();
			isstatic_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.isStatic)
		}

		// optional int32 layer = 4;
		inline bool GameObject::has_layer() const {
			return (_has_bits_[0] & 0x00000008u) != 0;
		}
		inline void GameObject::set_has_layer() {
			_has_bits_[0] |= 0x00000008u;
		}
		inline void GameObject::clear_has_layer() {
			_has_bits_[0] &= ~0x00000008u;
		}
		inline void GameObject::clear_layer() {
			layer_ = 0;
			clear_has_layer();
		}
		inline ::google::protobuf::int32 GameObject::layer() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.layer)
			return layer_;
		}
		inline void GameObject::set_layer(::google::protobuf::int32 value) {
			set_has_layer();
			layer_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.layer)
		}

		// optional int32 instanceID = 5;
		inline bool GameObject::has_instanceid() const {
			return (_has_bits_[0] & 0x00000010u) != 0;
		}
		inline void GameObject::set_has_instanceid() {
			_has_bits_[0] |= 0x00000010u;
		}
		inline void GameObject::clear_has_instanceid() {
			_has_bits_[0] &= ~0x00000010u;
		}
		inline void GameObject::clear_instanceid() {
			instanceid_ = 0;
			clear_has_instanceid();
		}
		inline ::google::protobuf::int32 GameObject::instanceid() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.instanceID)
			return instanceid_;
		}
		inline void GameObject::set_instanceid(::google::protobuf::int32 value) {
			set_has_instanceid();
			instanceid_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.instanceID)
		}

		// optional string tag = 6;
		inline bool GameObject::has_tag() const {
			return (_has_bits_[0] & 0x00000020u) != 0;
		}
		inline void GameObject::set_has_tag() {
			_has_bits_[0] |= 0x00000020u;
		}
		inline void GameObject::clear_has_tag() {
			_has_bits_[0] &= ~0x00000020u;
		}
		inline void GameObject::clear_tag() {
			tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_tag();
		}
		inline const ::std::string& GameObject::tag() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
			return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void GameObject::set_tag(const ::std::string& value) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
		}
		inline void GameObject::set_tag(const char* value) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
		}
		inline void GameObject::set_tag(const char* value, size_t size) {
			set_has_tag();
			tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
		}
		inline ::std::string* GameObject::mutable_tag() {
			set_has_tag();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
			return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* GameObject::release_tag() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
			clear_has_tag();
			return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void GameObject::set_allocated_tag(::std::string* tag) {
			if (tag != NULL) {
				set_has_tag();
			}
			else {
				clear_has_tag();
			}
			tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 7;
		inline bool GameObject::has_transform() const {
			return (_has_bits_[0] & 0x00000040u) != 0;
		}
		inline void GameObject::set_has_transform() {
			_has_bits_[0] |= 0x00000040u;
		}
		inline void GameObject::clear_has_transform() {
			_has_bits_[0] &= ~0x00000040u;
		}
		inline void GameObject::clear_transform() {
			if (transform_ != NULL) transform_->::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::Clear();
			clear_has_transform();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& GameObject::transform() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.transform)
			return transform_ != NULL ? *transform_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* GameObject::mutable_transform() {
			set_has_transform();
			if (transform_ == NULL) {
				transform_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.transform)
			return transform_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* GameObject::release_transform() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.transform)
			clear_has_transform();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* temp = transform_;
			transform_ = NULL;
			return temp;
		}
		inline void GameObject::set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform) {
			delete transform_;
			transform_ = transform;
			if (transform) {
				set_has_transform();
			}
			else {
				clear_has_transform();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.transform)
		}

		// optional string strType = 8;
		inline bool GameObject::has_strtype() const {
			return (_has_bits_[0] & 0x00000080u) != 0;
		}
		inline void GameObject::set_has_strtype() {
			_has_bits_[0] |= 0x00000080u;
		}
		inline void GameObject::clear_has_strtype() {
			_has_bits_[0] &= ~0x00000080u;
		}
		inline void GameObject::clear_strtype() {
			strtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_strtype();
		}
		inline const ::std::string& GameObject::strtype() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
			return strtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void GameObject::set_strtype(const ::std::string& value) {
			set_has_strtype();
			strtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
		}
		inline void GameObject::set_strtype(const char* value) {
			set_has_strtype();
			strtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
		}
		inline void GameObject::set_strtype(const char* value, size_t size) {
			set_has_strtype();
			strtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
		}
		inline ::std::string* GameObject::mutable_strtype() {
			set_has_strtype();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
			return strtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* GameObject::release_strtype() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
			clear_has_strtype();
			return strtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void GameObject::set_allocated_strtype(::std::string* strtype) {
			if (strtype != NULL) {
				set_has_strtype();
			}
			else {
				clear_has_strtype();
			}
			strtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strtype);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
		}

		// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Component list_Component = 9;
		inline int GameObject::list_component_size() const {
			return list_component_.size();
		}
		inline void GameObject::clear_list_component() {
			list_component_.Clear();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Component& GameObject::list_component(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.list_Component)
			return list_component_.Get(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Component* GameObject::mutable_list_component(int index) {
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.list_Component)
			return list_component_.Mutable(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Component* GameObject::add_list_component() {
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.list_Component)
			return list_component_.Add();
		}
		inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >*
			GameObject::mutable_list_component() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.list_Component)
			return &list_component_;
		}
		inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Component >&
			GameObject::list_component() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.list_Component)
			return list_component_;
		}

		inline const GameObject* GameObject::internal_default_instance() {
			return &GameObject_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// Scene

		// optional string strIndicate = 1;
		inline bool Scene::has_strindicate() const {
			return (_has_bits_[0] & 0x00000001u) != 0;
		}
		inline void Scene::set_has_strindicate() {
			_has_bits_[0] |= 0x00000001u;
		}
		inline void Scene::clear_has_strindicate() {
			_has_bits_[0] &= ~0x00000001u;
		}
		inline void Scene::clear_strindicate() {
			strindicate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
			clear_has_strindicate();
		}
		inline const ::std::string& Scene::strindicate() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
			return strindicate_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void Scene::set_strindicate(const ::std::string& value) {
			set_has_strindicate();
			strindicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
		}
		inline void Scene::set_strindicate(const char* value) {
			set_has_strindicate();
			strindicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
		}
		inline void Scene::set_strindicate(const char* value, size_t size) {
			set_has_strindicate();
			strindicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
				::std::string(reinterpret_cast<const char*>(value), size));
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
		}
		inline ::std::string* Scene::mutable_strindicate() {
			set_has_strindicate();
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
			return strindicate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline ::std::string* Scene::release_strindicate() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
			clear_has_strindicate();
			return strindicate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
		}
		inline void Scene::set_allocated_strindicate(::std::string* strindicate) {
			if (strindicate != NULL) {
				set_has_strindicate();
			}
			else {
				clear_has_strindicate();
			}
			strindicate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strindicate);
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Time time = 2;
		inline bool Scene::has_time() const {
			return (_has_bits_[0] & 0x00000002u) != 0;
		}
		inline void Scene::set_has_time() {
			_has_bits_[0] |= 0x00000002u;
		}
		inline void Scene::clear_has_time() {
			_has_bits_[0] &= ~0x00000002u;
		}
		inline void Scene::clear_time() {
			if (time_ != NULL) time_->::MSAnalyzer::MOSKIT_UNITY_LIB::Time::Clear();
			clear_has_time();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Time& Scene::time() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.time)
			return time_ != NULL ? *time_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::Time::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Time* Scene::mutable_time() {
			set_has_time();
			if (time_ == NULL) {
				time_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Time;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.time)
			return time_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Time* Scene::release_time() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.time)
			clear_has_time();
			::MSAnalyzer::MOSKIT_UNITY_LIB::Time* temp = time_;
			time_ = NULL;
			return temp;
		}
		inline void Scene::set_allocated_time(::MSAnalyzer::MOSKIT_UNITY_LIB::Time* time) {
			delete time_;
			time_ = time;
			if (time) {
				set_has_time();
			}
			else {
				clear_has_time();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.time)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera Camera = 3;
		inline bool Scene::has_camera() const {
			return (_has_bits_[0] & 0x00000004u) != 0;
		}
		inline void Scene::set_has_camera() {
			_has_bits_[0] |= 0x00000004u;
		}
		inline void Scene::clear_has_camera() {
			_has_bits_[0] &= ~0x00000004u;
		}
		inline void Scene::clear_camera() {
			if (camera_ != NULL) camera_->::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera::Clear();
			clear_has_camera();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera& Scene::camera() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Camera)
			return camera_ != NULL ? *camera_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* Scene::mutable_camera() {
			set_has_camera();
			if (camera_ == NULL) {
				camera_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Camera)
			return camera_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* Scene::release_camera() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Camera)
			clear_has_camera();
			::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* temp = camera_;
			camera_ = NULL;
			return temp;
		}
		inline void Scene::set_allocated_camera(::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* camera) {
			delete camera_;
			camera_ = camera;
			if (camera) {
				set_has_camera();
			}
			else {
				clear_has_camera();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Camera)
		}

		// optional float fScaleRatio = 4;
		inline bool Scene::has_fscaleratio() const {
			return (_has_bits_[0] & 0x00000008u) != 0;
		}
		inline void Scene::set_has_fscaleratio() {
			_has_bits_[0] |= 0x00000008u;
		}
		inline void Scene::clear_has_fscaleratio() {
			_has_bits_[0] &= ~0x00000008u;
		}
		inline void Scene::clear_fscaleratio() {
			fscaleratio_ = 0;
			clear_has_fscaleratio();
		}
		inline float Scene::fscaleratio() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.fScaleRatio)
			return fscaleratio_;
		}
		inline void Scene::set_fscaleratio(float value) {
			set_has_fscaleratio();
			fscaleratio_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.fScaleRatio)
		}

		// optional bool bVSync = 5;
		inline bool Scene::has_bvsync() const {
			return (_has_bits_[0] & 0x00000010u) != 0;
		}
		inline void Scene::set_has_bvsync() {
			_has_bits_[0] |= 0x00000010u;
		}
		inline void Scene::clear_has_bvsync() {
			_has_bits_[0] &= ~0x00000010u;
		}
		inline void Scene::clear_bvsync() {
			bvsync_ = false;
			clear_has_bvsync();
		}
		inline bool Scene::bvsync() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.bVSync)
			return bvsync_;
		}
		inline void Scene::set_bvsync(bool value) {
			set_has_bvsync();
			bvsync_ = value;
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.bVSync)
		}

		// optional .MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer Analysis_Buffer = 6;
		inline bool Scene::has_analysis_buffer() const {
			return (_has_bits_[0] & 0x00000020u) != 0;
		}
		inline void Scene::set_has_analysis_buffer() {
			_has_bits_[0] |= 0x00000020u;
		}
		inline void Scene::clear_has_analysis_buffer() {
			_has_bits_[0] &= ~0x00000020u;
		}
		inline void Scene::clear_analysis_buffer() {
			if (analysis_buffer_ != NULL) analysis_buffer_->::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer::Clear();
			clear_has_analysis_buffer();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer& Scene::analysis_buffer() const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Analysis_Buffer)
			return analysis_buffer_ != NULL ? *analysis_buffer_
				: *::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer::internal_default_instance();
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer* Scene::mutable_analysis_buffer() {
			set_has_analysis_buffer();
			if (analysis_buffer_ == NULL) {
				analysis_buffer_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer;
			}
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Analysis_Buffer)
			return analysis_buffer_;
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer* Scene::release_analysis_buffer() {
			// @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Analysis_Buffer)
			clear_has_analysis_buffer();
			::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer* temp = analysis_buffer_;
			analysis_buffer_ = NULL;
			return temp;
		}
		inline void Scene::set_allocated_analysis_buffer(::MSAnalyzer::MOSKIT_UNITY_LIB::AnalysisBuffer* analysis_buffer) {
			delete analysis_buffer_;
			analysis_buffer_ = analysis_buffer;
			if (analysis_buffer) {
				set_has_analysis_buffer();
			}
			else {
				clear_has_analysis_buffer();
			}
			// @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Analysis_Buffer)
		}

		// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Controller list_Controller = 7;
		inline int Scene::list_controller_size() const {
			return list_controller_.size();
		}
		inline void Scene::clear_list_controller() {
			list_controller_.Clear();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller& Scene::list_controller(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_Controller)
			return list_controller_.Get(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller* Scene::mutable_list_controller(int index) {
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_Controller)
			return list_controller_.Mutable(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller* Scene::add_list_controller() {
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_Controller)
			return list_controller_.Add();
		}
		inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller >*
			Scene::mutable_list_controller() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_Controller)
			return &list_controller_;
		}
		inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Controller >&
			Scene::list_controller() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_Controller)
			return list_controller_;
		}

		// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.GameObject list_gameObject = 8;
		inline int Scene::list_gameobject_size() const {
			return list_gameobject_.size();
		}
		inline void Scene::clear_list_gameobject() {
			list_gameobject_.Clear();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject& Scene::list_gameobject(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
			return list_gameobject_.Get(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* Scene::mutable_list_gameobject(int index) {
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
			return list_gameobject_.Mutable(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* Scene::add_list_gameobject() {
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
			return list_gameobject_.Add();
		}
		inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >*
			Scene::mutable_list_gameobject() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
			return &list_gameobject_;
		}
		inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >&
			Scene::list_gameobject() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
			return list_gameobject_;
		}

		inline const Scene* Scene::internal_default_instance() {
			return &Scene_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// ArrayScene

		// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Scene list_Scene = 1;
		inline int ArrayScene::list_scene_size() const {
			return list_scene_.size();
		}
		inline void ArrayScene::clear_list_scene() {
			list_scene_.Clear();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene& ArrayScene::list_scene(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
			return list_scene_.Get(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene* ArrayScene::mutable_list_scene(int index) {
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
			return list_scene_.Mutable(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene* ArrayScene::add_list_scene() {
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
			return list_scene_.Add();
		}
		inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene >*
			ArrayScene::mutable_list_scene() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
			return &list_scene_;
		}
		inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene >&
			ArrayScene::list_scene() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
			return list_scene_;
		}

		inline const ArrayScene* ArrayScene::internal_default_instance() {
			return &ArrayScene_default_instance_.get();
		}
		// -------------------------------------------------------------------

		// AnalysisBuffer

		// repeated int32 list_Int = 1;
		inline int AnalysisBuffer::list_int_size() const {
			return list_int_.size();
		}
		inline void AnalysisBuffer::clear_list_int() {
			list_int_.Clear();
		}
		inline ::google::protobuf::int32 AnalysisBuffer::list_int(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Int)
			return list_int_.Get(index);
		}
		inline void AnalysisBuffer::set_list_int(int index, ::google::protobuf::int32 value) {
			list_int_.Set(index, value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Int)
		}
		inline void AnalysisBuffer::add_list_int(::google::protobuf::int32 value) {
			list_int_.Add(value);
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Int)
		}
		inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
			AnalysisBuffer::list_int() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Int)
			return list_int_;
		}
		inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
			AnalysisBuffer::mutable_list_int() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Int)
			return &list_int_;
		}

		// repeated float list_Float = 2;
		inline int AnalysisBuffer::list_float_size() const {
			return list_float_.size();
		}
		inline void AnalysisBuffer::clear_list_float() {
			list_float_.Clear();
		}
		inline float AnalysisBuffer::list_float(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Float)
			return list_float_.Get(index);
		}
		inline void AnalysisBuffer::set_list_float(int index, float value) {
			list_float_.Set(index, value);
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Float)
		}
		inline void AnalysisBuffer::add_list_float(float value) {
			list_float_.Add(value);
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Float)
		}
		inline const ::google::protobuf::RepeatedField< float >&
			AnalysisBuffer::list_float() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Float)
			return list_float_;
		}
		inline ::google::protobuf::RepeatedField< float >*
			AnalysisBuffer::mutable_list_float() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Float)
			return &list_float_;
		}

		// repeated string list_String = 3;
		inline int AnalysisBuffer::list_string_size() const {
			return list_string_.size();
		}
		inline void AnalysisBuffer::clear_list_string() {
			list_string_.Clear();
		}
		inline const ::std::string& AnalysisBuffer::list_string(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
			return list_string_.Get(index);
		}
		inline ::std::string* AnalysisBuffer::mutable_list_string(int index) {
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
			return list_string_.Mutable(index);
		}
		inline void AnalysisBuffer::set_list_string(int index, const ::std::string& value) {
			// @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
			list_string_.Mutable(index)->assign(value);
		}
		inline void AnalysisBuffer::set_list_string(int index, const char* value) {
			list_string_.Mutable(index)->assign(value);
			// @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
		}
		inline void AnalysisBuffer::set_list_string(int index, const char* value, size_t size) {
			list_string_.Mutable(index)->assign(
				reinterpret_cast<const char*>(value), size);
			// @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
		}
		inline ::std::string* AnalysisBuffer::add_list_string() {
			// @@protoc_insertion_point(field_add_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
			return list_string_.Add();
		}
		inline void AnalysisBuffer::add_list_string(const ::std::string& value) {
			list_string_.Add()->assign(value);
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
		}
		inline void AnalysisBuffer::add_list_string(const char* value) {
			list_string_.Add()->assign(value);
			// @@protoc_insertion_point(field_add_char:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
		}
		inline void AnalysisBuffer::add_list_string(const char* value, size_t size) {
			list_string_.Add()->assign(reinterpret_cast<const char*>(value), size);
			// @@protoc_insertion_point(field_add_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
		}
		inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
			AnalysisBuffer::list_string() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
			return list_string_;
		}
		inline ::google::protobuf::RepeatedPtrField< ::std::string>*
			AnalysisBuffer::mutable_list_string() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_String)
			return &list_string_;
		}

		// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 list_Vector3 = 4;
		inline int AnalysisBuffer::list_vector3_size() const {
			return list_vector3_.size();
		}
		inline void AnalysisBuffer::clear_list_vector3() {
			list_vector3_.Clear();
		}
		inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& AnalysisBuffer::list_vector3(int index) const {
			// @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Vector3)
			return list_vector3_.Get(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* AnalysisBuffer::mutable_list_vector3(int index) {
			// @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Vector3)
			return list_vector3_.Mutable(index);
		}
		inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* AnalysisBuffer::add_list_vector3() {
			// @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Vector3)
			return list_vector3_.Add();
		}
		inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3 >*
			AnalysisBuffer::mutable_list_vector3() {
			// @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Vector3)
			return &list_vector3_;
		}
		inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3 >&
			AnalysisBuffer::list_vector3() const {
			// @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.AnalysisBuffer.list_Vector3)
			return list_vector3_;
		}

		inline const AnalysisBuffer* AnalysisBuffer::internal_default_instance() {
			return &AnalysisBuffer_default_instance_.get();
		}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
		// -------------------------------------------------------------------

		// -------------------------------------------------------------------

		// -------------------------------------------------------------------

		// -------------------------------------------------------------------

		// -------------------------------------------------------------------

		// -------------------------------------------------------------------

		// -------------------------------------------------------------------

		// -------------------------------------------------------------------

		// -------------------------------------------------------------------


		// @@protoc_insertion_point(namespace_scope)

	}  // namespace MOSKIT_UNITY_LIB
}  // namespace MSAnalyzer

   // @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_moskit_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: moskit.proto

#ifndef PROTOBUF_moskit_2eproto__INCLUDED
#define PROTOBUF_moskit_2eproto__INCLUDED


#ifdef _MSC_VER
#include "AllowWindowsPlatformTypes.h" // Added for UE4 in 2018-01-29 00:32:34.339969(UTC)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

#ifdef _MSC_VER
#include "HideWindowsPlatformTypes.h" // Added for UE4 in 2018-01-29 00:32:34.339969(UTC)
#endif


namespace MSAnalyzer {
namespace MOSKIT_UNITY_LIB {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_moskit_2eproto();
void protobuf_InitDefaults_moskit_2eproto();
void protobuf_AssignDesc_moskit_2eproto();
void protobuf_ShutdownFile_moskit_2eproto();

class ArrayScene;
class GameObject;
class MainCamera;
class ResultAnalysis;
class Scene;
class Time;
class Transform;
class Vector3;

// ===================================================================

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3) */ {
 public:
  Vector3();
  Vector3(const FVector& value)
  {
	  set_x(value.X);
	  set_y(value.Y);
	  set_z(value.Z);
  };
  Vector3(const FRotator& value)
  {
	  set_x(value.Roll);
	  set_y(value.Pitch);
	  set_z(value.Yaw);

  };
  Vector3(float x, float y, float z)
  {
	  set_x(x);
	  set_y(y);
	  set_z(z);
  };
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
	  CopyFrom(from);
	  return *this;
  }
  inline Vector3& operator=(const FVector from)
  {
	  set_x(from.X);
	  set_y(from.Y);
	  set_z(from.Z);
	  return *this;
  }
  inline Vector3& operator=(const FRotator from)
  {
	  set_x(from.Roll);
	  set_y(from.Pitch);
	  set_z(from.Yaw);

	  return *this;
  }

  float magnitude()
  {
	  return sqrtf(this->x_ * this->x_ + this->y_ * this->y_ + this->z_ * this->z_);
  }


  Vector3 operator *(float d)
  {
	  return Vector3(x_ * d, y_ * d, z_ * d);
  }
  Vector3 operator /(float d)
  {
	  return Vector3(x_ / d, y_ / d, z_ / d);
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  static const Vector3* internal_default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  inline Vector3* New() const { return New(NULL); }

  Vector3* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector3* other);
  void UnsafeMergeFrom(const Vector3& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_InitDefaults_moskit_2eproto_impl();
  friend void  protobuf_AddDesc_moskit_2eproto_impl();
  friend void protobuf_AssignDesc_moskit_2eproto();
  friend void protobuf_ShutdownFile_moskit_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Vector3> Vector3_default_instance_;

// -------------------------------------------------------------------

class Transform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Transform) */ {
 public:
  Transform();
  virtual ~Transform();

  Transform(const Transform& from);

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transform& default_instance();

  static const Transform* internal_default_instance();

  void Swap(Transform* other);

  // implements Message ----------------------------------------------

  inline Transform* New() const { return New(NULL); }

  Transform* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transform* other);
  void UnsafeMergeFrom(const Transform& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 eulerAngles = 1;
  bool has_eulerangles() const;
  void clear_eulerangles();
  static const int kEulerAnglesFieldNumber = 1;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& eulerangles() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_eulerangles();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_eulerangles();
  void set_allocated_eulerangles(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* eulerangles);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& position() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_position();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_position();
  void set_allocated_position(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* position);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 angularVelocity = 3;
  bool has_angularvelocity() const;
  void clear_angularvelocity();
  static const int kAngularVelocityFieldNumber = 3;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& angularvelocity() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_angularvelocity();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_angularvelocity();
  void set_allocated_angularvelocity(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* angularvelocity);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 scale = 4;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 4;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& scale() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_scale();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_scale();
  void set_allocated_scale(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* scale);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 forward = 5;
  bool has_forward() const;
  void clear_forward();
  static const int kForwardFieldNumber = 5;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& forward() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_forward();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_forward();
  void set_allocated_forward(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* forward);

  // optional int32 parent = 6;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 6;
  ::google::protobuf::int32 parent() const;
  void set_parent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Transform)
 private:
  inline void set_has_eulerangles();
  inline void clear_has_eulerangles();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_angularvelocity();
  inline void clear_has_angularvelocity();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* eulerangles_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* position_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* angularvelocity_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* scale_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* forward_;
  ::google::protobuf::int32 parent_;
  friend void  protobuf_InitDefaults_moskit_2eproto_impl();
  friend void  protobuf_AddDesc_moskit_2eproto_impl();
  friend void protobuf_AssignDesc_moskit_2eproto();
  friend void protobuf_ShutdownFile_moskit_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Transform> Transform_default_instance_;

// -------------------------------------------------------------------

class MainCamera : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera) */ {
 public:
  MainCamera();
  virtual ~MainCamera();

  MainCamera(const MainCamera& from);

  inline MainCamera& operator=(const MainCamera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MainCamera& default_instance();

  static const MainCamera* internal_default_instance();

  void Swap(MainCamera* other);

  // implements Message ----------------------------------------------

  inline MainCamera* New() const { return New(NULL); }

  MainCamera* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MainCamera& from);
  void MergeFrom(const MainCamera& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MainCamera* other);
  void UnsafeMergeFrom(const MainCamera& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool active = 2;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 2;
  bool active() const;
  void set_active(bool value);

  // optional int32 layer = 3;
  bool has_layer() const;
  void clear_layer();
  static const int kLayerFieldNumber = 3;
  ::google::protobuf::int32 layer() const;
  void set_layer(::google::protobuf::int32 value);

  // optional int32 instanceID = 4;
  bool has_instanceid() const;
  void clear_instanceid();
  static const int kInstanceIDFieldNumber = 4;
  ::google::protobuf::int32 instanceid() const;
  void set_instanceid(::google::protobuf::int32 value);

  // optional string tag = 5;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 5;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 6;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 6;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& transform() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* mutable_transform();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* release_transform();
  void set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 hitpoint = 7;
  bool has_hitpoint() const;
  void clear_hitpoint();
  static const int kHitpointFieldNumber = 7;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& hitpoint() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* mutable_hitpoint();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* release_hitpoint();
  void set_allocated_hitpoint(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* hitpoint);

  // @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_transform();
  inline void clear_has_transform();
  inline void set_has_hitpoint();
  inline void clear_has_hitpoint();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* hitpoint_;
  bool active_;
  ::google::protobuf::int32 layer_;
  ::google::protobuf::int32 instanceid_;
  friend void  protobuf_InitDefaults_moskit_2eproto_impl();
  friend void  protobuf_AddDesc_moskit_2eproto_impl();
  friend void protobuf_AssignDesc_moskit_2eproto();
  friend void protobuf_ShutdownFile_moskit_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MainCamera> MainCamera_default_instance_;

// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Time) */ {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  static const Time* internal_default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  inline Time* New() const { return New(NULL); }

  Time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Time* other);
  void UnsafeMergeFrom(const Time& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float deltaTime = 1;
  bool has_deltatime() const;
  void clear_deltatime();
  static const int kDeltaTimeFieldNumber = 1;
  float deltatime() const;
  void set_deltatime(float value);

  // optional int32 frameCount = 2;
  bool has_framecount() const;
  void clear_framecount();
  static const int kFrameCountFieldNumber = 2;
  ::google::protobuf::int32 framecount() const;
  void set_framecount(::google::protobuf::int32 value);

  // optional float time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  float time() const;
  void set_time(float value);

  // @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Time)
 private:
  inline void set_has_deltatime();
  inline void clear_has_deltatime();
  inline void set_has_framecount();
  inline void clear_has_framecount();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float deltatime_;
  ::google::protobuf::int32 framecount_;
  float time_;
  friend void  protobuf_InitDefaults_moskit_2eproto_impl();
  friend void  protobuf_AddDesc_moskit_2eproto_impl();
  friend void protobuf_AssignDesc_moskit_2eproto();
  friend void protobuf_ShutdownFile_moskit_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Time> Time_default_instance_;

// -------------------------------------------------------------------

class GameObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject) */ {
 public:
  GameObject();
  virtual ~GameObject();

  GameObject(const GameObject& from);

  inline GameObject& operator=(const GameObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameObject& default_instance();

  static const GameObject* internal_default_instance();

  void Swap(GameObject* other);

  // implements Message ----------------------------------------------

  inline GameObject* New() const { return New(NULL); }

  GameObject* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameObject& from);
  void MergeFrom(const GameObject& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameObject* other);
  void UnsafeMergeFrom(const GameObject& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool active = 2;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 2;
  bool active() const;
  void set_active(bool value);

  // optional bool isStatic = 3;
  bool has_isstatic() const;
  void clear_isstatic();
  static const int kIsStaticFieldNumber = 3;
  bool isstatic() const;
  void set_isstatic(bool value);

  // optional int32 layer = 4;
  bool has_layer() const;
  void clear_layer();
  static const int kLayerFieldNumber = 4;
  ::google::protobuf::int32 layer() const;
  void set_layer(::google::protobuf::int32 value);

  // optional int32 instanceID = 5;
  bool has_instanceid() const;
  void clear_instanceid();
  static const int kInstanceIDFieldNumber = 5;
  ::google::protobuf::int32 instanceid() const;
  void set_instanceid(::google::protobuf::int32 value);

  // optional string tag = 6;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 6;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 7;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 7;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& transform() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* mutable_transform();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* release_transform();
  void set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform);

  // optional string strType = 8;
  bool has_strtype() const;
  void clear_strtype();
  static const int kStrTypeFieldNumber = 8;
  const ::std::string& strtype() const;
  void set_strtype(const ::std::string& value);
  void set_strtype(const char* value);
  void set_strtype(const char* value, size_t size);
  ::std::string* mutable_strtype();
  ::std::string* release_strtype();
  void set_allocated_strtype(::std::string* strtype);

  // @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_isstatic();
  inline void clear_has_isstatic();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_transform();
  inline void clear_has_transform();
  inline void set_has_strtype();
  inline void clear_has_strtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::google::protobuf::internal::ArenaStringPtr strtype_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform_;
  bool active_;
  bool isstatic_;
  ::google::protobuf::int32 layer_;
  ::google::protobuf::int32 instanceid_;
  friend void  protobuf_InitDefaults_moskit_2eproto_impl();
  friend void  protobuf_AddDesc_moskit_2eproto_impl();
  friend void protobuf_AssignDesc_moskit_2eproto();
  friend void protobuf_ShutdownFile_moskit_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GameObject> GameObject_default_instance_;

// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.Scene) */ {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  static const Scene* internal_default_instance();

  void Swap(Scene* other);

  // implements Message ----------------------------------------------

  inline Scene* New() const { return New(NULL); }

  Scene* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Scene* other);
  void UnsafeMergeFrom(const Scene& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string strIndicate = 1;
  bool has_strindicate() const;
  void clear_strindicate();
  static const int kStrIndicateFieldNumber = 1;
  const ::std::string& strindicate() const;
  void set_strindicate(const ::std::string& value);
  void set_strindicate(const char* value);
  void set_strindicate(const char* value, size_t size);
  ::std::string* mutable_strindicate();
  ::std::string* release_strindicate();
  void set_allocated_strindicate(::std::string* strindicate);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.Time time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Time& time() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Time* mutable_time();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Time* release_time();
  void set_allocated_time(::MSAnalyzer::MOSKIT_UNITY_LIB::Time* time);

  // optional .MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera Camera = 3;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 3;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera& camera() const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* mutable_camera();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* release_camera();
  void set_allocated_camera(::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* camera);

  // repeated .MSAnalyzer.MOSKIT_UNITY_LIB.GameObject list_gameObject = 4;
  int list_gameobject_size() const;
  void clear_list_gameobject();
  static const int kListGameObjectFieldNumber = 4;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject& list_gameobject(int index) const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* mutable_list_gameobject(int index);
  ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* add_list_gameobject();
  ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >*
      mutable_list_gameobject();
  const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >&
      list_gameobject() const;

  // @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.Scene)
 private:
  inline void set_has_strindicate();
  inline void clear_has_strindicate();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_camera();
  inline void clear_has_camera();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject > list_gameobject_;
  ::google::protobuf::internal::ArenaStringPtr strindicate_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Time* time_;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* camera_;
  friend void  protobuf_InitDefaults_moskit_2eproto_impl();
  friend void  protobuf_AddDesc_moskit_2eproto_impl();
  friend void protobuf_AssignDesc_moskit_2eproto();
  friend void protobuf_ShutdownFile_moskit_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Scene> Scene_default_instance_;

// -------------------------------------------------------------------

class ResultAnalysis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.ResultAnalysis) */ {
 public:
  ResultAnalysis();
  virtual ~ResultAnalysis();

  ResultAnalysis(const ResultAnalysis& from);

  inline ResultAnalysis& operator=(const ResultAnalysis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultAnalysis& default_instance();

  static const ResultAnalysis* internal_default_instance();

  void Swap(ResultAnalysis* other);

  // implements Message ----------------------------------------------

  inline ResultAnalysis* New() const { return New(NULL); }

  ResultAnalysis* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultAnalysis& from);
  void MergeFrom(const ResultAnalysis& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultAnalysis* other);
  void UnsafeMergeFrom(const ResultAnalysis& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MSAnalyzer.MOSKIT_UNITY_LIB.GameObject list_obj = 1;
  int list_obj_size() const;
  void clear_list_obj();
  static const int kListObjFieldNumber = 1;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject& list_obj(int index) const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* mutable_list_obj(int index);
  ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* add_list_obj();
  ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >*
      mutable_list_obj();
  const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >&
      list_obj() const;

  // @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.ResultAnalysis)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject > list_obj_;
  friend void  protobuf_InitDefaults_moskit_2eproto_impl();
  friend void  protobuf_AddDesc_moskit_2eproto_impl();
  friend void protobuf_AssignDesc_moskit_2eproto();
  friend void protobuf_ShutdownFile_moskit_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ResultAnalysis> ResultAnalysis_default_instance_;

// -------------------------------------------------------------------

class ArrayScene : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene) */ {
 public:
  ArrayScene();
  virtual ~ArrayScene();

  ArrayScene(const ArrayScene& from);

  inline ArrayScene& operator=(const ArrayScene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArrayScene& default_instance();

  static const ArrayScene* internal_default_instance();

  void Swap(ArrayScene* other);

  // implements Message ----------------------------------------------

  inline ArrayScene* New() const { return New(NULL); }

  ArrayScene* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArrayScene& from);
  void MergeFrom(const ArrayScene& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayScene* other);
  void UnsafeMergeFrom(const ArrayScene& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Scene list_Scene = 1;
  int list_scene_size() const;
  void clear_list_scene();
  static const int kListSceneFieldNumber = 1;
  const ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene& list_scene(int index) const;
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene* mutable_list_scene(int index);
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene* add_list_scene();
  ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene >*
      mutable_list_scene();
  const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene >&
      list_scene() const;

  // @@protoc_insertion_point(class_scope:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene > list_scene_;
  friend void  protobuf_InitDefaults_moskit_2eproto_impl();
  friend void  protobuf_AddDesc_moskit_2eproto_impl();
  friend void protobuf_AssignDesc_moskit_2eproto();
  friend void protobuf_ShutdownFile_moskit_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ArrayScene> ArrayScene_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector3

// optional float x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.x)
}

// optional float y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.y)
}

// optional float z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Vector3.z)
}

inline const Vector3* Vector3::internal_default_instance() {
  return &Vector3_default_instance_.get();
}
// -------------------------------------------------------------------

// Transform

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 eulerAngles = 1;
inline bool Transform::has_eulerangles() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transform::set_has_eulerangles() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transform::clear_has_eulerangles() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transform::clear_eulerangles() {
  if (eulerangles_ != NULL) eulerangles_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
  clear_has_eulerangles();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::eulerangles() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.eulerAngles)
  return eulerangles_ != NULL ? *eulerangles_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_eulerangles() {
  set_has_eulerangles();
  if (eulerangles_ == NULL) {
    eulerangles_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.eulerAngles)
  return eulerangles_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_eulerangles() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.eulerAngles)
  clear_has_eulerangles();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = eulerangles_;
  eulerangles_ = NULL;
  return temp;
}
inline void Transform::set_allocated_eulerangles(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* eulerangles) {
  delete eulerangles_;
  eulerangles_ = eulerangles;
  if (eulerangles) {
    set_has_eulerangles();
  } else {
    clear_has_eulerangles();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.eulerAngles)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 position = 2;
inline bool Transform::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transform::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transform::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transform::clear_position() {
  if (position_ != NULL) position_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
  clear_has_position();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::position() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.position)
  return position_ != NULL ? *position_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.position)
  return position_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_position() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.position)
  clear_has_position();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Transform::set_allocated_position(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.position)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 angularVelocity = 3;
inline bool Transform::has_angularvelocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transform::set_has_angularvelocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transform::clear_has_angularvelocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transform::clear_angularvelocity() {
  if (angularvelocity_ != NULL) angularvelocity_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
  clear_has_angularvelocity();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::angularvelocity() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.angularVelocity)
  return angularvelocity_ != NULL ? *angularvelocity_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_angularvelocity() {
  set_has_angularvelocity();
  if (angularvelocity_ == NULL) {
    angularvelocity_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.angularVelocity)
  return angularvelocity_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_angularvelocity() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.angularVelocity)
  clear_has_angularvelocity();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = angularvelocity_;
  angularvelocity_ = NULL;
  return temp;
}
inline void Transform::set_allocated_angularvelocity(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* angularvelocity) {
  delete angularvelocity_;
  angularvelocity_ = angularvelocity;
  if (angularvelocity) {
    set_has_angularvelocity();
  } else {
    clear_has_angularvelocity();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.angularVelocity)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 scale = 4;
inline bool Transform::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transform::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transform::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transform::clear_scale() {
  if (scale_ != NULL) scale_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
  clear_has_scale();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::scale() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.scale)
  return scale_ != NULL ? *scale_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) {
    scale_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.scale)
  return scale_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_scale() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.scale)
  clear_has_scale();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Transform::set_allocated_scale(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.scale)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 forward = 5;
inline bool Transform::has_forward() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transform::set_has_forward() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transform::clear_has_forward() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transform::clear_forward() {
  if (forward_ != NULL) forward_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
  clear_has_forward();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& Transform::forward() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.forward)
  return forward_ != NULL ? *forward_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::mutable_forward() {
  set_has_forward();
  if (forward_ == NULL) {
    forward_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.forward)
  return forward_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* Transform::release_forward() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.forward)
  clear_has_forward();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = forward_;
  forward_ = NULL;
  return temp;
}
inline void Transform::set_allocated_forward(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* forward) {
  delete forward_;
  forward_ = forward;
  if (forward) {
    set_has_forward();
  } else {
    clear_has_forward();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.forward)
}

// optional int32 parent = 6;
inline bool Transform::has_parent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Transform::set_has_parent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Transform::clear_has_parent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Transform::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::google::protobuf::int32 Transform::parent() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.parent)
  return parent_;
}
inline void Transform::set_parent(::google::protobuf::int32 value) {
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Transform.parent)
}

inline const Transform* Transform::internal_default_instance() {
  return &Transform_default_instance_.get();
}
// -------------------------------------------------------------------

// MainCamera

// optional string name = 1;
inline bool MainCamera::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MainCamera::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MainCamera::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MainCamera::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MainCamera::name() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MainCamera::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
}
inline void MainCamera::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
}
inline void MainCamera::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
}
inline ::std::string* MainCamera::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MainCamera::release_name() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MainCamera::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.name)
}

// optional bool active = 2;
inline bool MainCamera::has_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MainCamera::set_has_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MainCamera::clear_has_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MainCamera::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool MainCamera::active() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.active)
  return active_;
}
inline void MainCamera::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.active)
}

// optional int32 layer = 3;
inline bool MainCamera::has_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MainCamera::set_has_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MainCamera::clear_has_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MainCamera::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MainCamera::layer() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.layer)
  return layer_;
}
inline void MainCamera::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.layer)
}

// optional int32 instanceID = 4;
inline bool MainCamera::has_instanceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MainCamera::set_has_instanceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MainCamera::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MainCamera::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 MainCamera::instanceid() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.instanceID)
  return instanceid_;
}
inline void MainCamera::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.instanceID)
}

// optional string tag = 5;
inline bool MainCamera::has_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MainCamera::set_has_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MainCamera::clear_has_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MainCamera::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tag();
}
inline const ::std::string& MainCamera::tag() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
  return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MainCamera::set_tag(const ::std::string& value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
}
inline void MainCamera::set_tag(const char* value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
}
inline void MainCamera::set_tag(const char* value, size_t size) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
}
inline ::std::string* MainCamera::mutable_tag() {
  set_has_tag();
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MainCamera::release_tag() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
  clear_has_tag();
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MainCamera::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.tag)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 6;
inline bool MainCamera::has_transform() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MainCamera::set_has_transform() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MainCamera::clear_has_transform() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MainCamera::clear_transform() {
  if (transform_ != NULL) transform_->::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::Clear();
  clear_has_transform();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& MainCamera::transform() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.transform)
  return transform_ != NULL ? *transform_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* MainCamera::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) {
    transform_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.transform)
  return transform_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* MainCamera::release_transform() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.transform)
  clear_has_transform();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void MainCamera::set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    set_has_transform();
  } else {
    clear_has_transform();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.transform)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Vector3 hitpoint = 7;
inline bool MainCamera::has_hitpoint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MainCamera::set_has_hitpoint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MainCamera::clear_has_hitpoint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MainCamera::clear_hitpoint() {
  if (hitpoint_ != NULL) hitpoint_->::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::Clear();
  clear_has_hitpoint();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3& MainCamera::hitpoint() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.hitpoint)
  return hitpoint_ != NULL ? *hitpoint_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* MainCamera::mutable_hitpoint() {
  set_has_hitpoint();
  if (hitpoint_ == NULL) {
    hitpoint_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.hitpoint)
  return hitpoint_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* MainCamera::release_hitpoint() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.hitpoint)
  clear_has_hitpoint();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* temp = hitpoint_;
  hitpoint_ = NULL;
  return temp;
}
inline void MainCamera::set_allocated_hitpoint(::MSAnalyzer::MOSKIT_UNITY_LIB::Vector3* hitpoint) {
  delete hitpoint_;
  hitpoint_ = hitpoint;
  if (hitpoint) {
    set_has_hitpoint();
  } else {
    clear_has_hitpoint();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera.hitpoint)
}

inline const MainCamera* MainCamera::internal_default_instance() {
  return &MainCamera_default_instance_.get();
}
// -------------------------------------------------------------------

// Time

// optional float deltaTime = 1;
inline bool Time::has_deltatime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_deltatime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_deltatime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_deltatime() {
  deltatime_ = 0;
  clear_has_deltatime();
}
inline float Time::deltatime() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Time.deltaTime)
  return deltatime_;
}
inline void Time::set_deltatime(float value) {
  set_has_deltatime();
  deltatime_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Time.deltaTime)
}

// optional int32 frameCount = 2;
inline bool Time::has_framecount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_framecount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_framecount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_framecount() {
  framecount_ = 0;
  clear_has_framecount();
}
inline ::google::protobuf::int32 Time::framecount() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Time.frameCount)
  return framecount_;
}
inline void Time::set_framecount(::google::protobuf::int32 value) {
  set_has_framecount();
  framecount_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Time.frameCount)
}

// optional float time = 3;
inline bool Time::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Time::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Time::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Time::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float Time::time() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Time.time)
  return time_;
}
inline void Time::set_time(float value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Time.time)
}

inline const Time* Time::internal_default_instance() {
  return &Time_default_instance_.get();
}
// -------------------------------------------------------------------

// GameObject

// optional string name = 1;
inline bool GameObject::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameObject::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameObject::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameObject::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GameObject::name() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameObject::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
}
inline void GameObject::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
}
inline void GameObject::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
}
inline ::std::string* GameObject::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameObject::release_name() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameObject::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.name)
}

// optional bool active = 2;
inline bool GameObject::has_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameObject::set_has_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameObject::clear_has_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameObject::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool GameObject::active() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.active)
  return active_;
}
inline void GameObject::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.active)
}

// optional bool isStatic = 3;
inline bool GameObject::has_isstatic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameObject::set_has_isstatic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameObject::clear_has_isstatic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameObject::clear_isstatic() {
  isstatic_ = false;
  clear_has_isstatic();
}
inline bool GameObject::isstatic() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.isStatic)
  return isstatic_;
}
inline void GameObject::set_isstatic(bool value) {
  set_has_isstatic();
  isstatic_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.isStatic)
}

// optional int32 layer = 4;
inline bool GameObject::has_layer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameObject::set_has_layer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameObject::clear_has_layer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameObject::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 GameObject::layer() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.layer)
  return layer_;
}
inline void GameObject::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.layer)
}

// optional int32 instanceID = 5;
inline bool GameObject::has_instanceid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameObject::set_has_instanceid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameObject::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameObject::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 GameObject::instanceid() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.instanceID)
  return instanceid_;
}
inline void GameObject::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.instanceID)
}

// optional string tag = 6;
inline bool GameObject::has_tag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameObject::set_has_tag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameObject::clear_has_tag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameObject::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tag();
}
inline const ::std::string& GameObject::tag() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
  return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameObject::set_tag(const ::std::string& value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
}
inline void GameObject::set_tag(const char* value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
}
inline void GameObject::set_tag(const char* value, size_t size) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
}
inline ::std::string* GameObject::mutable_tag() {
  set_has_tag();
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameObject::release_tag() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
  clear_has_tag();
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameObject::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.tag)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Transform transform = 7;
inline bool GameObject::has_transform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameObject::set_has_transform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameObject::clear_has_transform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameObject::clear_transform() {
  if (transform_ != NULL) transform_->::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::Clear();
  clear_has_transform();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform& GameObject::transform() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.transform)
  return transform_ != NULL ? *transform_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Transform::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* GameObject::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) {
    transform_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.transform)
  return transform_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* GameObject::release_transform() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.transform)
  clear_has_transform();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void GameObject::set_allocated_transform(::MSAnalyzer::MOSKIT_UNITY_LIB::Transform* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    set_has_transform();
  } else {
    clear_has_transform();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.transform)
}

// optional string strType = 8;
inline bool GameObject::has_strtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameObject::set_has_strtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameObject::clear_has_strtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameObject::clear_strtype() {
  strtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_strtype();
}
inline const ::std::string& GameObject::strtype() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
  return strtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameObject::set_strtype(const ::std::string& value) {
  set_has_strtype();
  strtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
}
inline void GameObject::set_strtype(const char* value) {
  set_has_strtype();
  strtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
}
inline void GameObject::set_strtype(const char* value, size_t size) {
  set_has_strtype();
  strtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
}
inline ::std::string* GameObject::mutable_strtype() {
  set_has_strtype();
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
  return strtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameObject::release_strtype() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
  clear_has_strtype();
  return strtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameObject::set_allocated_strtype(::std::string* strtype) {
  if (strtype != NULL) {
    set_has_strtype();
  } else {
    clear_has_strtype();
  }
  strtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strtype);
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.GameObject.strType)
}

inline const GameObject* GameObject::internal_default_instance() {
  return &GameObject_default_instance_.get();
}
// -------------------------------------------------------------------

// Scene

// optional string strIndicate = 1;
inline bool Scene::has_strindicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scene::set_has_strindicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scene::clear_has_strindicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scene::clear_strindicate() {
  strindicate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_strindicate();
}
inline const ::std::string& Scene::strindicate() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
  return strindicate_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scene::set_strindicate(const ::std::string& value) {
  set_has_strindicate();
  strindicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
}
inline void Scene::set_strindicate(const char* value) {
  set_has_strindicate();
  strindicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
}
inline void Scene::set_strindicate(const char* value, size_t size) {
  set_has_strindicate();
  strindicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
}
inline ::std::string* Scene::mutable_strindicate() {
  set_has_strindicate();
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
  return strindicate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scene::release_strindicate() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
  clear_has_strindicate();
  return strindicate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scene::set_allocated_strindicate(::std::string* strindicate) {
  if (strindicate != NULL) {
    set_has_strindicate();
  } else {
    clear_has_strindicate();
  }
  strindicate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strindicate);
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.strIndicate)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.Time time = 2;
inline bool Scene::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scene::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Scene::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Scene::clear_time() {
  if (time_ != NULL) time_->::MSAnalyzer::MOSKIT_UNITY_LIB::Time::Clear();
  clear_has_time();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Time& Scene::time() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.time)
  return time_ != NULL ? *time_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::Time::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Time* Scene::mutable_time() {
  set_has_time();
  if (time_ == NULL) {
    time_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::Time;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.time)
  return time_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Time* Scene::release_time() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.time)
  clear_has_time();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::Time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Scene::set_allocated_time(::MSAnalyzer::MOSKIT_UNITY_LIB::Time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.time)
}

// optional .MSAnalyzer.MOSKIT_UNITY_LIB.MainCamera Camera = 3;
inline bool Scene::has_camera() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Scene::set_has_camera() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Scene::clear_has_camera() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Scene::clear_camera() {
  if (camera_ != NULL) camera_->::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera::Clear();
  clear_has_camera();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera& Scene::camera() const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Camera)
  return camera_ != NULL ? *camera_
                         : *::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera::internal_default_instance();
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* Scene::mutable_camera() {
  set_has_camera();
  if (camera_ == NULL) {
    camera_ = new ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera;
  }
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Camera)
  return camera_;
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* Scene::release_camera() {
  // @@protoc_insertion_point(field_release:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Camera)
  clear_has_camera();
  ::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* temp = camera_;
  camera_ = NULL;
  return temp;
}
inline void Scene::set_allocated_camera(::MSAnalyzer::MOSKIT_UNITY_LIB::MainCamera* camera) {
  delete camera_;
  camera_ = camera;
  if (camera) {
    set_has_camera();
  } else {
    clear_has_camera();
  }
  // @@protoc_insertion_point(field_set_allocated:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.Camera)
}

// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.GameObject list_gameObject = 4;
inline int Scene::list_gameobject_size() const {
  return list_gameobject_.size();
}
inline void Scene::clear_list_gameobject() {
  list_gameobject_.Clear();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject& Scene::list_gameobject(int index) const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
  return list_gameobject_.Get(index);
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* Scene::mutable_list_gameobject(int index) {
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
  return list_gameobject_.Mutable(index);
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* Scene::add_list_gameobject() {
  // @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
  return list_gameobject_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >*
Scene::mutable_list_gameobject() {
  // @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
  return &list_gameobject_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >&
Scene::list_gameobject() const {
  // @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.Scene.list_gameObject)
  return list_gameobject_;
}

inline const Scene* Scene::internal_default_instance() {
  return &Scene_default_instance_.get();
}
// -------------------------------------------------------------------

// ResultAnalysis

// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.GameObject list_obj = 1;
inline int ResultAnalysis::list_obj_size() const {
  return list_obj_.size();
}
inline void ResultAnalysis::clear_list_obj() {
  list_obj_.Clear();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject& ResultAnalysis::list_obj(int index) const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.ResultAnalysis.list_obj)
  return list_obj_.Get(index);
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* ResultAnalysis::mutable_list_obj(int index) {
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.ResultAnalysis.list_obj)
  return list_obj_.Mutable(index);
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject* ResultAnalysis::add_list_obj() {
  // @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.ResultAnalysis.list_obj)
  return list_obj_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >*
ResultAnalysis::mutable_list_obj() {
  // @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.ResultAnalysis.list_obj)
  return &list_obj_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::GameObject >&
ResultAnalysis::list_obj() const {
  // @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.ResultAnalysis.list_obj)
  return list_obj_;
}

inline const ResultAnalysis* ResultAnalysis::internal_default_instance() {
  return &ResultAnalysis_default_instance_.get();
}
// -------------------------------------------------------------------

// ArrayScene

// repeated .MSAnalyzer.MOSKIT_UNITY_LIB.Scene list_Scene = 1;
inline int ArrayScene::list_scene_size() const {
  return list_scene_.size();
}
inline void ArrayScene::clear_list_scene() {
  list_scene_.Clear();
}
inline const ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene& ArrayScene::list_scene(int index) const {
  // @@protoc_insertion_point(field_get:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
  return list_scene_.Get(index);
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene* ArrayScene::mutable_list_scene(int index) {
  // @@protoc_insertion_point(field_mutable:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
  return list_scene_.Mutable(index);
}
inline ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene* ArrayScene::add_list_scene() {
  // @@protoc_insertion_point(field_add:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
  return list_scene_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene >*
ArrayScene::mutable_list_scene() {
  // @@protoc_insertion_point(field_mutable_list:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
  return &list_scene_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MSAnalyzer::MOSKIT_UNITY_LIB::Scene >&
ArrayScene::list_scene() const {
  // @@protoc_insertion_point(field_list:MSAnalyzer.MOSKIT_UNITY_LIB.ArrayScene.list_Scene)
  return list_scene_;
}

inline const ArrayScene* ArrayScene::internal_default_instance() {
  return &ArrayScene_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MOSKIT_UNITY_LIB
}  // namespace MSAnalyzer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_moskit_2eproto__INCLUDED
